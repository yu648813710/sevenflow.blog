<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>react render 以及 update 在fiber架构前后的差异</title>
    <link href="/sevenflow.blog/2023/03/25/react%20render%20%E4%BB%A5%E5%8F%8A%20update%20%E5%9C%A8fiber%E6%9E%B6%E6%9E%84%E5%89%8D%E5%90%8E%E7%9A%84%E5%B7%AE%E5%BC%82/"/>
    <url>/sevenflow.blog/2023/03/25/react%20render%20%E4%BB%A5%E5%8F%8A%20update%20%E5%9C%A8fiber%E6%9E%B6%E6%9E%84%E5%89%8D%E5%90%8E%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li><p>jsx语法是需要babel转译成 createElement可以接受的对象 然后在react方法中使用的。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> Test = <span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-keyword">const</span> Button = <span class="hljs-function">(<span class="hljs-params">&#123;label&#125;</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>&#123;label&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">return</span> (<br>&lt;h1&gt;<br>test<br>&lt;Button label=<span class="hljs-string">&quot;click&quot;</span>/&gt;<br>&lt;/h1&gt;<br>)<br>&#125;<br><br><span class="hljs-comment">// babel转化后如下</span><br><br><span class="hljs-keyword">const</span> Test = <span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-keyword">const</span> Button = <span class="hljs-function">(<span class="hljs-params">&#123;label&#125;</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> React.createElement(<span class="hljs-string">&#x27;button&#x27;</span>, &#123;&#125;, label)<br>&#125;<br><br><span class="hljs-keyword">return</span> (<br>React.createElement(<span class="hljs-string">&#x27;h1&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;test&#x27;</span>, React.createElement(Button, &#123;<span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;click&#x27;</span>&#125;))<br>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>fiber的出现是为了让react的更新粒度更小，可以不长时间阻塞JS执行的主线程</p></li><li><p>不阻塞执行的方式 是react 内部写了一个类似于requestIdleCallback 的方法，在JS空闲时进行render</p><h2 id="搭建react-源码调试"><a href="#搭建react-源码调试" class="headerlink" title="搭建react 源码调试"></a>搭建react 源码调试</h2></li><li><p>下载 react源码<br>  <a href="https://github.com/facebook/react/tags">Tags · facebook/react (github.com)</a> `</p></li><li><p>选中需要调试的包，比如v15.6.1</p><ul><li>选中<code>react</code> 与 <code>react-dom</code>的未压缩的文件</li></ul></li><li><p>初始化项目</p><ul><li>建立<code>index.html</code>，引入<code>react</code>与<code>react-dom</code>文件如下<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./react.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./react-dom.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>建立<code>index.js</code>文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-built_in">window</span>.onload = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> e = React.createElement;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>      <span class="hljs-built_in">super</span>(props);<br>      <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">liked</span>: <span class="hljs-literal">false</span> &#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state.liked) &#123;<br>        <span class="hljs-keyword">return</span> e(<br>          <span class="hljs-string">&#x27;button&#x27;</span>,<br>          &#123;  &#125;,<br>          <span class="hljs-string">&#x27;You liked this.&#x27;</span><br>        );<br>      &#125;<br>      <span class="hljs-keyword">return</span> e(<br>        <span class="hljs-string">&#x27;button&#x27;</span>,<br>        &#123; <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">liked</span>: <span class="hljs-literal">true</span> &#125;) &#125;,<br>        <span class="hljs-string">&#x27;Like&#x27;</span><br>      );<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> domContainer = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#root&#x27;</span>);<br>  ReactDOM.render(e(LikeButton), domContainer);<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>浏览器打开<code>index.html</code>文件，在<code>index.js</code>render函数打上断点</p></li><li><p>打断点需要知道自己要看的是什么，比如我想看的是 怎么样render到页面上的，以及update是怎么样的，那么其他相关函数我就直接跳出</p><h2 id="15版本的react-render-以及update"><a href="#15版本的react-render-以及update" class="headerlink" title="15版本的react render 以及update"></a>15版本的react render 以及update</h2><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3></li></ul><blockquote><p>递归生成虚拟dom节点并插入root dom中</p></blockquote><h4 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h4><ul><li>生成的虚拟dom与本身组件的嵌套关系一致，是树状结构，与真实的dom对象也一致，下图为整体流程<br>![Pasted image 20221204134129](D:\编程学习\读书笔记\MDImage\Pasted image 20221204134129.png)</li></ul><h4 id="debugger-过程细读"><a href="#debugger-过程细读" class="headerlink" title="debugger 过程细读"></a>debugger 过程细读</h4><ul><li><p>ReactDOM.render(e(Box), domContainer);</p><ul><li>执行 render的时候 ，传参有函数，进行执行 <code>e(Box)</code>, e 函数来自于React.createElement</li><li>React.createElement 处理 jsx对象 为 虚拟dom对象 , 主要是靠 ReactElement.createElement 方法进行处理<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> element = ReactElement.createElement.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br></code></pre></td></tr></table></figure></li><li>利用 ReactElement 函数生成 element 对象如下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> element = &#123;<br><span class="hljs-comment">// This tag allow us to uniquely identify this as a React Element</span><br>$$typeof: REACT_ELEMENT_TYPE,<br>  <br><span class="hljs-comment">// Built-in properties that belong on the element</span><br>type: type, <span class="hljs-comment">// 其实</span><br>key: key,<br>ref: ref,<br>props: props,<br>  <br><span class="hljs-comment">// Record the component responsible for creating this element.</span><br>_owner: owner<br> &#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>执行 react-dom里的render函数 接受参数 为 element 对象 以及 domContainer的真实dom</p><ul><li><p>render直接 执行了 ReactMount._renderSubtreeIntoContainer 函数 如下</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">render: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nextElement, container, callback</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> ReactMount._renderSubtreeIntoContainer(<span class="hljs-literal">null</span>, nextElement, container, callback);<br>&#125;,<br></code></pre></td></tr></table></figure></li><li><p>_renderSubtreeIntoContainer 函数内部 利用 React.createElement 再次生成 root 的 element 对象，这个时候 element对象的 props里的 child包含了 第一次 传参的 element</p><p>![Pasted image 20221213145037](D:\编程学习\读书笔记\MDImage\Pasted image 20221213145037.png)</p></li></ul></li><li><p>执行 ReactMount._renderNewRootComponent ，这个方法是 渲染的主要方法，传递了nextElement 就是刚才执行完的element对象 如下</p><p>![Pasted image 20221213145951](D:\编程学习\读书笔记\MDImage\Pasted image 20221213145951.png)    </p><ul><li><p>执行 instantiateReactComponent 方法 传递 nextElement，主要是为了 把 element对象再次包装生成新的 实例对象 ，为后面的函数运行做准备<br>![Pasted image 20221213150932](D:\编程学习\读书笔记\MDImage\Pasted image 20221213150932.png)</p></li><li><p>执行 ReactUpdates.batchedUpdates 方法， 传参刚才包装好的实例对象，进行批量更新</p><ul><li><p>通过 preform 的批量处理更新的 方法 执行 mountComponentIntoNode， 把element 对象进行封装 <code>ReactDOMContainerInfo</code> 为 后面的 ReactReconciler.mountComponent函数来做准备</p><blockquote><p>mountComponent 方法在react中有多个，但是每个用途都不一样 ReactReconciler.mountComponent 是为了初始化组件、render 虚拟dom并注册事件侦听器。</p></blockquote></li><li><p>在 mountComponent 函数中 会执行 本身react的class组件 的 render方法 ，下图是render的方法以及运行环境的变量</p><p><img src="D:\编程学习\读书笔记\MDImage\image-20221214103924590.png" alt="image-20221214103924590"></p><p>在执行render的时候 遇见type 为函数的会再次执行到 React.createElement 方法 ，依次形成递归处理每一个 需要 createElement的方法，拿到最后顶层render出的 element 对象，如下</p><p><img src="D:\编程学习\读书笔记\MDImage\image-20221214121720978.png" alt="image-20221214121720978"></p><p>他们的关系为 一个树状的数据结构，也是我们经常提起过的虚拟dom树，不过现在的虚拟dom树 还没有与真实dom相关联</p><h6 id=""><a href="#" class="headerlink" title=""></a><img src="D:\编程学习\读书笔记\MDImage\image-20221214124411243.png" alt="image-20221214124411243"></h6></li></ul></li></ul></li><li><p>render完成后 生成的element对象用于 internalInstance.mountComponent的方法，这个方法是为了递归生成真实的dom ，并且注册监听事件</p><ul><li><p>利用 ownerDocument.createElement 创建真实dom 对象 </p></li><li><p>ReactDOMComponentTree.precacheNode  把真实的 dom对象 缓存在 当前 element 对象上的 _hostNode ，把 当前element 对象缓存在 真实dom对象的名叫 internalInstanceKey 的key上 具体代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">precacheNode</span>(<span class="hljs-params">inst, node</span>) </span>&#123;<span class="hljs-comment">// element对象 以及 真实dom对象</span><br>  <span class="hljs-keyword">var</span> hostInst = getRenderedHostOrTextFromComponent(inst);<br>  hostInst._hostNode = node;<br>  node[internalInstanceKey] = hostInst; <span class="hljs-comment">// internalInstanceKey = &#x27;__reactInternalInstance$&#x27; + Math.random().toString(36).slice(2);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这步很重要 ，缓存了element对象后 以及 真实的dom对象后，意味着从真实的dom的event对象 可以获取 当前的虚拟element对象，也可以从虚拟的element对象 获取 ，具体结构如下图</p><p><img src="D:\编程学习\读书笔记\MDImage\image-20221214141435545.png" alt="image-20221214141435545"></p></li><li><p>创建 真实dom后 ，执行 **_updateDOMProperties **方法 对真实dom 进行 props的属性处理，这里处理了 事件监听 也处理了其他像style之类的属性值</p><ul><li><p>利用 enqueuePutListener 方法 对 事件进行 委托绑定 把所有事件统一绑定在 最顶层的 html 元素上，并且与 ReactEventListener.dispatchEvent 绑定</p></li><li><p>然后执行事件的时候 会冒泡到 委托元素，委托元素拿到事件对象event，通过event可以拿到真实dom对象 以及对象中的 react 虚拟dom对象 ，从而执行 相关的props 事件 如下</p><p><img src="D:\编程学习\读书笔记\MDImage\image-20221215131311093.png" alt="image-20221215131311093"></p></li></ul></li></ul></li><li><p>然后 依次 处理 children对象 ，利用 mountChildren 函数，这个函数内部其实 是 对children对象 进行 for循环 处理，然后 执行 ReactReconciler.mountComponent方法 又走回之前第一个element对象的 处理流程了，代码如下</p><p><img src="D:\编程学习\读书笔记\MDImage\image-20221214142339132.png" alt="image-20221214142339132"></p></li><li><p>生成mountImages，然后把children appendChild 进父节点 形成一个 真实的 node 对象，真实的node 节点本身就是树状结构，不过因为上面 precacheNode 方法的处理 导致 真实的node 节点的dom对象中还有当前层级的 虚拟dom对象 ，如下</p><p> <img src="D:\编程学习\读书笔记\MDImage\image-20221214143654637.png" alt="image-20221214143654637"></p></li></ul><ul><li>运行 ReactMount._mountImageIntoNode 函数，传递 真实node对象，把真实的 node  <code>insertBefore</code>进 root 节点，完成渲染</li></ul><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><h4 id="总流程-1"><a href="#总流程-1" class="headerlink" title="总流程"></a>总流程</h4><p>![Pasted image 20221204163404](D:\编程学习\读书笔记\MDImage\Pasted image 20221204163404.png)</p><h4 id="debugger过程细读"><a href="#debugger过程细读" class="headerlink" title="debugger过程细读"></a>debugger过程细读</h4><ul><li><p>执行setState，把 更新的 state 传递给 this.updater.enqueueSetState 方法</p><ul><li><p>传参 更新的state，以及本身实例对象， 实例对象就是之前说的虚拟的dom节点，因为本身这个this指向的是当前运行setState的 组件环境上下文，而组件本身的虚拟dom节点 就在 <strong>_reactInternalInstance</strong> 这个key中如下</p><p><img src="D:\编程学习\读书笔记\MDImage\image-20221214150940603.png" alt="image-20221214150940603"></p></li><li><p>在当前实例创建 <strong>_pendingStateQueue</strong>队列 ，队列中是放置 更新的 state</p></li></ul></li><li><p>调用 enqueueUpdate 方法 更新 dirtyComponents 数组</p><ul><li>接受有queue队列的实例，dirtyComponents  push进 当前需要更新的 component 实例<ul><li>所以这块有一个点 就是 如果更新是高层级组件 ，那就意味着高层级下的叶子节点 都要进行 更新对比，所以 <code>shouldComponentUpdate</code>这个优化就很有作用了</li></ul></li></ul></li><li><p>执行 flushBatchedUpdates 方法 ，对 dirtyComponents 进行 更新，如下图 只要有dirtyComponents就会一直执行</p><p><img src="D:\编程学习\读书笔记\MDImage\image-20221218135854766.png" alt="image-20221218135854766"></p></li><li><p>执行 runBatchedUpdates 方法 获取当前需要渲染的 dirtyComponents 然后 执行 <strong>updateComponent</strong>方法，拿到需要更新的 <strong>nextState</strong></p></li><li><p>执行 <strong>_performComponentUpdate</strong>，执行<code>willUpdate</code>生命周期</p></li><li><p>执行 <strong>_updateRenderedComponent</strong>, 通过拿到 <code>nextRenderedElement</code>对象 和 更新实例本身的 element对象 自己内部再做次对比 如下，如果不需要更新直接复用之前的elment对象，如果需要更新 执行 <code>mountComponent</code>又回到了render渲染</p><p><img src="D:\编程学习\读书笔记\MDImage\image-20221218183752851.png" alt="image-20221218183752851"></p><ul><li><p>内部的对比方法 <code>shouldUpdateReactComponent</code>, 主要是做了 <code>key</code> 以及虚拟dom对象的 <code>type</code>的对比，如果一致那么不更新直接复用，如下</p><p><img src="D:\编程学习\读书笔记\MDImage\image-20221218184231033.png" alt="image-20221218184231033"></p></li></ul></li><li><p>复用当前组件后 执行 <code>receiveComponent</code>方法 ，对 当前更新组件 的 props进行更新 执行 <strong>_updateDOMProperties</strong> 与 <strong>_updateDOMChildren</strong>方法，这个时候页面的DOM已经可以看到最新的更新信息了</p><ul><li>这两个方法在render过程中讲过，是一样的，更新完 就代表这个组件已经更新成功了</li></ul></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法暂停更新，只要有dirtyComponent 就会一直更新，而且如果dirtyComponent是层级过深的组件 ，会导致长时间执行</li><li>就算可以暂停更新，但是因为 updateDomchildren 会对当前已经存在的真实dom进行更新，会出现一部分dom更新了，一部分没用更新的问题，所以就出现了fiber架构</li></ul><h2 id="React-17-render-以及update"><a href="#React-17-render-以及update" class="headerlink" title="React 17 render 以及update"></a>React 17 render 以及update</h2><ul><li><p>和之前一样还是真实dom 对象中会有当前fiber的对象，但是fiber对象有了return的值，指向上一层元素，形成链表结构，如下</p><p>![Pasted image 20221205140537](D:\编程学习\读书笔记\MDImage\Pasted image 20221205140537.png)</p><h3 id="render过程"><a href="#render过程" class="headerlink" title="render过程"></a>render过程</h3><p><img src="D:\编程学习\读书笔记\MDImage\微信图片_20230109193940.png" alt="微信图片_20230109193940"></p></li></ul><h3 id="update-1"><a href="#update-1" class="headerlink" title="update"></a>update</h3><blockquote><p>拿useState进行举例</p></blockquote><p>![Pasted image 20221205134243](D:\编程学习\读书笔记\MDImage\Pasted image 20221205134243.png)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kasong.gitee.io/just-react/">React 技术揭秘 (gitee.io)</a></p><p><a href="https://pomb.us/build-your-own-react/">Build your own React (pomb.us)</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback">requestIdleCallback - Web API 接口参考 | MDN (mozilla.org)</a></p><p><a href="https://zh-hans.reactjs.org/docs/how-to-contribute.html">贡献流程 – React (reactjs.org)</a></p><p><a href="https://zhuanlan.zhihu.com/p/165089379">React 事件 | 1. React 中的事件委托 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>window终端优化</title>
    <link href="/sevenflow.blog/2022/08/25/windows%E7%BB%88%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    <url>/sevenflow.blog/2022/08/25/windows%E7%BB%88%E7%AB%AF%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="window终端优化"><a href="#window终端优化" class="headerlink" title="window终端优化"></a>window终端优化</h1><blockquote><p>电脑升级w11后，wsl彻底用不了了，因为有热更新的bug，导致我一个前端压根无法使用wsl，只好寻求其他的终端解决方案，在找资料的过程中才发现，原来powershell 的功能以及生态已经做的很好了，后面w11试了一下觉得可以，我的台式机w10也优化了，亲测有效！以下为我优化的步骤</p></blockquote><h2 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h2><ul><li><p>通过<code>Micorsoft Store</code>下载 <code>window Terminal</code></p></li><li><p>通过<code>Micorsoft Store</code>下载<code>oh my posh</code></p></li><li><p>下载<code>oh my posh</code>推荐字体 <a href="https://link.zhihu.com/?target=https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Meslo.zip">下载包地址</a></p></li><li><p>安装刚才的 下载字体到windows fonts里</p><h2 id="设置终端为oh-my-posh-主题"><a href="#设置终端为oh-my-posh-主题" class="headerlink" title="设置终端为oh my posh 主题"></a>设置终端为oh my posh 主题</h2></li><li><p>在<code>window Terminal</code>设置字体</p><ul><li><p>打开  <code>window Terminal</code>，用快捷键 <code>ctrl + shift + ,(逗号)</code>来打开 setting.json配置文件W</p></li><li><p>修改 <code>default</code>选项如下：</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">defaults: &#123;<br>font: &#123;<br>face: &quot;MesloLGM NF&quot;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>保存后 重新打开终端，输入<code>notepad $profile</code>并回车，询问你没有文件是否新建文件时点是即可</p></li><li><p>在文件中写入<code>oh-my-posh init pwsh | Invoke-Expression</code>，然后保存，重启终端，如下<br>  ![[Pasted image 20220816133554.png]]</p></li><li><p>如果想设置别的主题，先在终端查看有什么主题，输入命令并且回车 <code>Get-PoshThemes</code>，然后<code>oh my posh</code>会输出自己的主题，并且输出一个例子，你复制例子的命令修改里面的主题文件如下</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">oh</span><span class="hljs-literal">-my</span><span class="hljs-literal">-posh</span> init pwsh -<span class="hljs-literal">-config</span> C:\Users\你的路径\AppData\Local\Programs\oh<span class="hljs-literal">-my</span><span class="hljs-literal">-posh</span>\themes/主题名.omp.json | <span class="hljs-built_in">Invoke-Expression</span><br></code></pre></td></tr></table></figure></li><li><p>终端输入<code>notepad $profile</code>写入刚才复制的命令 然后保存</p></li><li><p>这里我用的 <code>pure</code>主题，最终结果如下</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9873dfde206444caa18fc9d30ec20b90~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image-20220816200428808"></p></li></ul></li></ul><h2 id="vscode-设置字体"><a href="#vscode-设置字体" class="headerlink" title="vscode 设置字体"></a>vscode 设置字体</h2><ul><li>在vscode 中打开设置，在设置-&gt;功能-&gt;终端中修改 <code>Font Family</code>为 <code>MesloLGM NF</code></li></ul><h2 id="powershell-功能增强"><a href="#powershell-功能增强" class="headerlink" title="powershell 功能增强"></a>powershell 功能增强</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>安装 PSReadline 包，该插件可以让命令行很好用，类似 zsh</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Install-Module</span> <span class="hljs-literal">-Name</span> PSReadLine <span class="hljs-literal">-Scope</span> CurrentUser<br></code></pre></td></tr></table></figure></li><li><p>安装 posh-git 包，让你的 git 更好用，以管理员运行 powershell 然后安装，安装不成功这个命令行加后缀 <code>-Force</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Install-Module</span> posh<span class="hljs-literal">-git</span> <span class="hljs-literal">-Scope</span> CurrentUser<br></code></pre></td></tr></table></figure></li><li><p>安装 DirColors 包，<code>ls</code>命令输出更为美观</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Install-Module DirColors<br></code></pre></td></tr></table></figure><h3 id="设置-profile"><a href="#设置-profile" class="headerlink" title="设置 $profile"></a>设置 <code>$profile</code></h3><p>因为刚才安装了module，所以相当于的也需要引入，和设置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs text"># 引入 posh-git<br>Import-Module posh-git<br><br># 引入 ps-read-line<br>Import-Module PSReadLine<br><br># 引入<br>Import-Module DirColors<br><br># 设置 ps-read-line<br><br># 设置预测文本来源为历史记录<br>Set-PSReadLineOption -PredictionSource History<br><br># 每次回溯输入历史，光标定位于输入内容末尾<br>Set-PSReadLineOption -HistorySearchCursorMovesToEnd<br><br># 设置 Tab 为菜单补全和 Intellisense<br>Set-PSReadLineKeyHandler -Key &quot;Tab&quot; -Function MenuComplete<br><br># 设置 Ctrl+d 为退出 PowerShell<br>Set-PSReadlineKeyHandler -Key &quot;Ctrl+d&quot; -Function ViExit<br><br># 设置 Ctrl+z 为撤销<br>Set-PSReadLineKeyHandler -Key &quot;Ctrl+z&quot; -Function Undo<br><br># 设置向上键为后向搜索历史记录<br>Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward<br><br># 设置向下键为前向搜索历史纪录<br>Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward<br></code></pre></td></tr></table></figure></li><li><p>写一个<code>open</code>快捷功能打开当前工作目录，编辑<code>$profile</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text"># 1. 打开当前工作目录<br>function OpenCurrentFolder &#123;<br>param<br>(<br># 输入要打开的路径<br># 用法示例：open C:\<br># 默认路径：当前工作文件夹<br>$Path = &#x27;.&#x27;<br>)<br>Invoke-Item $Path<br>&#125;<br>Set-Alias -Name open -Value OpenCurrentFolder<br></code></pre></td></tr></table></figure></li><li><p>写一个<code>ls</code>与<code>ll</code>功能</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text"># 2. 查看目录 ls &amp; ll<br>function ListDirectory &#123;<br>(Get-ChildItem).Name<br>Write-Host(&quot;&quot;)<br>&#125;<br>Remove-Item alias:\ls<br>Set-Alias -Name ls -Value ListDirectory<br>Set-Alias -Name ll -Value Get-ChildItem<br></code></pre></td></tr></table></figure><p>保存文件，重启终端</p></li></ul><h2 id="安装powershell-自己的包管理"><a href="#安装powershell-自己的包管理" class="headerlink" title="安装powershell 自己的包管理"></a>安装powershell 自己的包管理</h2><ul><li><p>安装 <code>scoop</code></p><p>网络报错可能就是需要梯子</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Invoke-Expression</span> (<span class="hljs-built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="hljs-string">&#x27;https://get.scoop.sh&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>使用<code>scoop</code></p><ul><li>比如下载 前端常用 <code>node</code>管理 <code>nvm</code><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">scoop search nvm<br></code></pre></td></tr></table></figure></li><li>输出<br>  <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/108bf586045d44bebc4516f66b7749d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image-20220816200438984"></li><li>安装<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">scoop install nvm<br></code></pre></td></tr></table></figure>比之前方便了很多<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>最终的<code>$profile</code>文件内容为<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs text"># 使用主题<br>oh-my-posh init pwsh | Invoke-Expression<br># 设置主题<br>oh-my-posh init pwsh --config C:\Users\wentao.yu\AppData\Local\Programs\oh-my-posh\themes/pure.omp.json | Invoke-Expression<br><br># 引入 posh-git<br>Import-Module posh-git<br><br># 引入 ps-read-line<br>Import-Module PSReadLine<br><br># 引入<br>Import-Module DirColors<br><br>#------------------------------- Import Modules END   -------------------------------<br><br>#-------------------------------  Set Hot-keys BEGIN  -------------------------------<br># 设置预测文本来源为历史记录<br>Set-PSReadLineOption -PredictionSource History<br><br># 每次回溯输入历史，光标定位于输入内容末尾<br>Set-PSReadLineOption -HistorySearchCursorMovesToEnd<br><br># 设置 Tab 为菜单补全和 Intellisense<br>Set-PSReadLineKeyHandler -Key &quot;Tab&quot; -Function MenuComplete<br><br># 设置 Ctrl+d 为退出 PowerShell<br>Set-PSReadlineKeyHandler -Key &quot;Ctrl+d&quot; -Function ViExit<br><br># 设置 Ctrl+z 为撤销<br>Set-PSReadLineKeyHandler -Key &quot;Ctrl+z&quot; -Function Undo<br><br># 设置向上键为后向搜索历史记录<br>Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward<br><br># 设置向下键为前向搜索历史纪录<br>Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward<br>#-------------------------------  Set Hot-keys END    -------------------------------<br>#-------------------------------   Set Alias BEGIN    -------------------------------<br><br># 1. 打开当前工作目录<br>function OpenCurrentFolder &#123;<br>param<br>(<br># 输入要打开的路径<br># 用法示例：open C:\<br># 默认路径：当前工作文件夹<br>$Path = &#x27;.&#x27;<br>)<br>Invoke-Item $Path<br>&#125;<br>Set-Alias -Name open -Value OpenCurrentFolder<br><br># 2. 查看目录 ls &amp; ll<br>function ListDirectory &#123;<br>(Get-ChildItem).Name<br>Write-Host(&quot;&quot;)<br>&#125;<br>Remove-Item alias:\ls<br>Set-Alias -Name ls -Value ListDirectory<br>Set-Alias -Name ll -Value Get-ChildItem<br><br>#-------------------------------    Set Alias END     -------------------------------<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="最终终端效果为"><a href="#最终终端效果为" class="headerlink" title="最终终端效果为"></a>最终终端效果为</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fca255a7a0548f082eb29acdf07c66f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image-20220816200451482"><br>带命令补全 以及 历史记录已经很方便了</p>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈富文本编辑器</title>
    <link href="/sevenflow.blog/2022/04/19/%E6%B5%85%E8%B0%88%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <url>/sevenflow.blog/2022/04/19/%E6%B5%85%E8%B0%88%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="一些概念与误解"><a href="#一些概念与误解" class="headerlink" title="一些概念与误解"></a>一些概念与误解</h2><h3 id="什么是富文本？"><a href="#什么是富文本？" class="headerlink" title="什么是富文本？"></a>什么是富文本？</h3><p>微软公司开发用来多平台阅读编辑的一种文件类型，RTF文档（Rich Text Forma），类似于word，现在多数指对文字可进行编辑排版的工具，如vscode也可以称为富文本</p><h3 id="前端所说的富文本指的是？"><a href="#前端所说的富文本指的是？" class="headerlink" title="前端所说的富文本指的是？"></a>前端所说的富文本指的是？</h3><p>统一是web端的富文本编辑器，也具备多端能力主要是网页本身具备多端运行能力</p><h2 id="常用的富文本编辑器"><a href="#常用的富文本编辑器" class="headerlink" title="常用的富文本编辑器"></a>常用的富文本编辑器</h2><ul><li><a href="https://fex.baidu.com/ueditor/">百度 UEditor</a></li><li><a href="https://quilljs.com/">quilljs</a></li><li><a href="https://github.com/wangeditor-team/wangEditor">wangEditor</a>  </li><li>Google Doc 与 腾讯文档</li></ul><h2 id="富文本编辑器的类型"><a href="#富文本编辑器的类型" class="headerlink" title="富文本编辑器的类型"></a>富文本编辑器的类型</h2><blockquote><p>来源于  <a href="https://juejin.cn/post/6952429235743129636">document.execCommand的探索</a></p></blockquote><table><thead><tr><th>类型</th><th>描述</th><th>代表</th><th>优劣</th></tr></thead><tbody><tr><td>L0</td><td>1. 基于浏览器的contenteditable属性完成富文本输入框<br/>2. 使用document.execCommand操作命令完成排版</td><td>轻量级编辑器<br/>典型代表：wangEditor，UEditor</td><td>优：短时间内快速研发<br />劣：可定制空间非常有限</td></tr><tr><td>L1</td><td>1. 基于浏览器的contentditable属性富文本输入框<br/>2. 自主实现操作命令完成排版</td><td>典型代表：draft.js(初始化了一个编辑区)、TinyMCE等</td><td>优：在浏览器的基础上，能满足大部分业务<br />劣：无法突破浏览器本身的排版效果，性能与HTML的局限问题</td></tr><tr><td>L2</td><td>1. 自主实现富文本输入框<br/>2. 只依赖少量浏览器API</td><td>Google Doc,腾讯文档，</td><td>优：都自己实现，可控度都掌握在开发者手里<br />劣：技术难度大</td></tr></tbody></table><p>此次分享仅仅针对 L0与L1做一次技术分享</p><h2 id="关于contenteditable-属性"><a href="#关于contenteditable-属性" class="headerlink" title="关于contenteditable 属性"></a>关于contenteditable 属性</h2><p>[全局属性]<a href="%E6%89%80%E6%9C%89html%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes</a> <strong>contenteditable</strong> 是一个枚举属性，表示元素是否可被用户编辑。 如果可以，浏览器会修改元素的部件以允许编辑, 默认继承父元素的当前属性值</p><ul><li><p>注意事项</p><ul><li>该属性是一个枚举属性，而非布尔属性。这意味着必须显式设置其值为 <code>true</code>、<code>false</code> 或空字符串中的一个，并且不允许简写为 <code>&lt;label contenteditable&gt;Example Label&lt;/label&gt;</code>正确的用法是 <code>&lt;label contenteditable=&quot;true&quot;&gt;Example Label&lt;/label&gt;</code>。</li></ul></li><li><p>oninput事件</p><ul><li>通过事件对象可获取编辑区域的Dom对象，从而拿到innerHtml 与innerText</li></ul></li></ul><p>举例</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> React, &#123; useState, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> [isEdit, setIsEdit] = useState(<span class="hljs-literal">true</span>);<br>   <span class="hljs-keyword">const</span> [htmlIfo, setHtmlIfo] = useState(<span class="hljs-literal">null</span>);<br><br>   <span class="hljs-keyword">const</span> onEdit = useCallback(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>     <span class="hljs-keyword">const</span> target = e.target;<br>     setHtmlIfo(target.innerHTML);<br>      &#125;, []);<br>    <br>    <span class="hljs-keyword">return</span> (<br>           &lt;div<br>            className=<span class="hljs-string">&quot;demoBox&quot;</span><br>            contentEditable=&#123;isEdit&#125;<br>            suppressContentEditableWarning<br>            onInput=&#123;onEdit&#125;<br>          &gt;<br>            &lt;h2&gt;我是标题&lt;/h2&gt;<br>            &lt;p&gt;我是段落&lt;/p&gt;<br>            &lt;p&gt;我是图片&lt;/p&gt;<br>          &lt;/div&gt;<br>      );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure><h2 id="关于-document-execCommand-的JS-方法"><a href="#关于-document-execCommand-的JS-方法" class="headerlink" title="关于 document.execCommand 的JS 方法"></a>关于 document.execCommand 的JS 方法</h2><h3 id="document-execCommand的介绍"><a href="#document-execCommand的介绍" class="headerlink" title="document.execCommand的介绍"></a>document.execCommand的介绍</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand#%E5%91%BD%E4%BB%A4">execcommand文档</a><ul><li>当一个HTML文档切换到<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/designMode">设计模式</a>时，<code>document</code>暴露 <strong><code>execCommand</code></strong> 方法，该方法允许运行命令来操纵<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/contenteditable">可编辑内容区域</a>的元素。大多数命令影响<code>document</code>的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection">selection</a>（粗体，斜体等）</li></ul></li><li>设计模式<ul><li><strong><code>document.designMode</code></strong> 控制整个文档是否可编辑。</li></ul></li><li>selection对象<ul><li>对象表示用户选择的文本范围或插入符号的当前位置。它代表页面中的文本选区，可能横跨多个元素。</li></ul></li></ul><p>举例</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> React, &#123; useState, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> commandMapData = [<br>  &#123;<br>    name: <span class="hljs-string">&quot;背景色&quot;</span>,<br>    commandKey: <span class="hljs-string">&quot;backColor&quot;</span>,<br>    value: <span class="hljs-string">&quot;#ccc&quot;</span>,<br>  &#125;,<br>  &#123;<br>    name: <span class="hljs-string">&quot;字体色&quot;</span>,<br>    commandKey: <span class="hljs-string">&quot;foreColor&quot;</span>,<br>    value: <span class="hljs-string">&quot;red&quot;</span>,<br>  &#125;,<br>  &#123;<br>    name: <span class="hljs-string">&quot;字体加粗&quot;</span>,<br>    commandKey: <span class="hljs-string">&quot;bold&quot;</span>,<br>  &#125;,<br>  &#123;<br>    name: <span class="hljs-string">&quot;删除&quot;</span>,<br>    commandKey: <span class="hljs-string">&quot;delete&quot;</span>,<br>  &#125;,<br>  &#123;<br>    name: <span class="hljs-string">&quot;撤销&quot;</span>,<br>    commandKey: <span class="hljs-string">&quot;undo&quot;</span>,<br>  &#125;,<br>  &#123;<br>    name: <span class="hljs-string">&quot;恢复&quot;</span>,<br>    commandKey: <span class="hljs-string">&quot;redo&quot;</span>,<br>  &#125;,<br>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> [isEdit, setIsEdit] = useState(<span class="hljs-literal">true</span>);<br>   <span class="hljs-keyword">const</span> [htmlIfo, setHtmlIfo] = useState(<span class="hljs-literal">null</span>);<br><br>   <span class="hljs-keyword">const</span> onEdit = useCallback(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>     <span class="hljs-keyword">const</span> target = e.target;<br>     setHtmlIfo(target.innerHTML);<br>      &#125;, []);<br><br>      <span class="hljs-comment">// 执行指令</span><br>      <span class="hljs-keyword">const</span> actionCommand = useCallback(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> key = e.target.dataset.key;<br><br>        <span class="hljs-keyword">const</span> index = commandMapData.findIndex(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.commandKey === key);<br>        <span class="hljs-built_in">document</span>.execCommand(key, <span class="hljs-literal">false</span>, commandMapData[index].value);<br>      &#125;, []);<br>    <br>    <span class="hljs-keyword">return</span> (<br>           &lt;div&gt;<br>            &lt;div&gt;<br>              &#123;commandMapData.map(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> (<br>                &lt;button<br>                  key=&#123;res.commandKey&#125;<br>                  data-key=&#123;res.commandKey&#125;<br>                  onClick=&#123;actionCommand&#125;<br>                &gt;<br>                  &#123;res.name&#125;<br>                &lt;/button&gt;<br>              ))&#125;<br>            &lt;/div&gt;<br>         &lt;div<br>                className=<span class="hljs-string">&quot;demoBox&quot;</span><br>                contentEditable=&#123;isEdit&#125;<br>                suppressContentEditableWarning<br>                onInput=&#123;onEdit&#125;<br>              &gt;<br>                &lt;h2&gt;我是标题&lt;/h2&gt;<br>                &lt;p&gt;我是段落&lt;/p&gt;<br>                &lt;p&gt;我是图片&lt;/p&gt;<br>              &lt;/div&gt;   <br>            &lt;/div&gt;<br>      );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure><h3 id="document-execCommand的局限性"><a href="#document-execCommand的局限性" class="headerlink" title="document.execCommand的局限性"></a>document.execCommand的局限性</h3><ul><li>兼容性问题，MDN已经显示主流浏览器废弃了这个api<ul><li>但是现在firefox还是chrom 等主流浏览器都还是支持的，所以废弃态度更像是不维护，不修复</li></ul></li><li>缺乏扩展性，一些业务BUG<ul><li>undo与 redo的全局影响</li><li>排版受限，排版必须按照指定命令来执行</li><li>等等</li></ul></li></ul><h2 id="业界富文本组件在做什么？"><a href="#业界富文本组件在做什么？" class="headerlink" title="业界富文本组件在做什么？"></a>业界富文本组件在做什么？</h2><blockquote><p>既然有浏览器行业标准API，那么那些富文本编辑器代码是在干什么？</p></blockquote><ul><li>处理 document.execCommand 的兼容问题<ul><li>如 insertHTML 和 increaseFontSize 不支持IE浏览器<ul><li>解决方案，利用selection找到光标位置，然后插入需要处理的数据</li></ul></li></ul></li><li>处理 document.execCommand 的业务逻辑BUG<ul><li>如undo与 redo对整个页面进行操作<ul><li>需要自己写一个栈数据，对用户操作记载，然后undo和redo</li></ul></li></ul></li><li>新的富文本利用selection和Range这两个属性重写 execCommand<ul><li>下面会详细说</li></ul></li><li>富文本功能的插件化<ul><li>功能可配置化</li></ul></li><li>处理 用户操作的负面问题<ul><li>如xss攻击预防<ul><li>字符串的正则检查，数据过滤</li></ul></li><li>如复制粘贴去除无用节点（更多是从word文件复制过来）<ul><li>正则检查，数据过滤</li></ul></li><li>如图片插入上传与复制上传处理<ul><li>插入上传利用 execCommand 可以做到，允许嵌入在线图片链接的</li><li>静态图片上传</li><li>复制上传需要监听 paste 事件，存在多种情况<ul><li>单独复制图片<ul><li>拿到 clipboardData 数据 然后进行处理</li></ul></li><li>和文本一块复制图片（HTML格式）<ul><li>复制图片为本地路径<ul><li>暂无解决方案</li></ul></li><li>复制图片为在线路径<ul><li>在线路径 利用正侧查找 img 标签，单独请求链接 然后处理</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="关于Selection-与-Range"><a href="#关于Selection-与-Range" class="headerlink" title="关于Selection 与 Range"></a>关于Selection 与 Range</h2><p>均为实验属性</p><h4 id="Selection-对象"><a href="#Selection-对象" class="headerlink" title="Selection 对象"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Selection">Selection 对象</a></h4><blockquote><p><code>Selection</code> 对象表示用户选择的文本范围或插入符号的当前位置。它代表页面中的文本选区，可能横跨多个元素。文本选区由用户拖拽鼠标经过文字而产生。</p></blockquote><p>所说的横跨多个元素，用户操作无法完成，必须JS进行选区添加，场景就是 多人协同修改文档，显示光标位置</p><h4 id="Range对象"><a href="#Range对象" class="headerlink" title="Range对象"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Range">Range对象</a></h4><blockquote><p>表示一个包含节点与文本节点的一部分的文档片段</p></blockquote><p>可以说selection对象有选区，那么就会有range对象</p><h3 id="尝试实现execCommand-功能"><a href="#尝试实现execCommand-功能" class="headerlink" title="尝试实现execCommand 功能"></a>尝试实现execCommand 功能</h3><p>已现有DEMO 为例，进行功能实现</p><ul><li><p>功能</p><ul><li>背景色</li><li>字体色</li><li>加粗</li><li>撤销与恢复</li></ul></li><li><p>方案</p><ul><li>获取光标选择区</li><li>对光标选择区进行编辑</li><li>undo与redo写一个数据操作栈，然后完成操作</li></ul></li><li><p>难点？</p><ul><li>关于Range 范围的嵌套Dom处理</li><li>关于undo与redo的光标位置处理</li><li>…</li></ul></li><li><p>现有demo地址,<strong><a href="https://github.com/yu648813710/richTextDemo">richTextDemo</a></strong></p></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/6952429235743129636">document.execCommand的探索</a></p><p><a href="https://www.zhihu.com/question/38699645">为什么都说富文本编辑器是天坑？</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand">MDN 文档</a></p><p><a href="https://drive.googleblog.com/2010/05/whats-different-about-new-google-docs.html">新版 Google 文档有什么不同？</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于网页适配的总结</title>
    <link href="/sevenflow.blog/2022/01/03/%E5%85%B3%E4%BA%8ETS%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"/>
    <url>/sevenflow.blog/2022/01/03/%E5%85%B3%E4%BA%8ETS%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="被我忽略的TS知识"><a href="#被我忽略的TS知识" class="headerlink" title="被我忽略的TS知识"></a>被我忽略的TS知识</h1><h2 id="implements-的使用"><a href="#implements-的使用" class="headerlink" title="implements 的使用"></a>implements 的使用</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><blockquote><p>对于 类 的行为属性进行 描述，我自己理解就是 class需要定义类型， 所以有了 impements存在，看一下用法 你就知道它的作用了</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 描述行为与属性</span><br><span class="hljs-keyword">interface</span> AType &#123;<br>    name: <span class="hljs-built_in">string</span>,<br>    showName: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-comment">// class 实现 这个描述</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-title">implements</span> <span class="hljs-title">AType</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;;<br><br>    name: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-function"><span class="hljs-title">showName</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 正常使用</span><br><span class="hljs-keyword">const</span> objA = <span class="hljs-keyword">new</span> A(<span class="hljs-string">&#x27;123&#x27;</span>);<br><br>objA.showName();<br></code></pre></td></tr></table></figure><p>关于 <code>type</code> 类也可以 <code>implements</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> BType = &#123;<br>    age: <span class="hljs-built_in">number</span>,<br>    showAge: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-title">implements</span> <span class="hljs-title">BType</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">age:<span class="hljs-built_in">number</span></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    age;<br><br>    showAge () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age+<span class="hljs-string">&#x27;年龄&#x27;</span>)<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> objB = <span class="hljs-keyword">new</span> B(<span class="hljs-number">23</span>);<br><br>objB.showAge();<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>class</code>的type定义 需要用到 <code>implments</code>关键字来实现</li><li><code>interface</code>与<code>type</code>均可定义class 类型</li></ul><h2 id="类型保护-type-guards"><a href="#类型保护-type-guards" class="headerlink" title="类型保护  type guards"></a>类型保护  type guards</h2><p>这个其实在<code>typescript</code>官方的高级类型中有写，但是自己学习囫囵吞枣，这一章节的东西直接全部忘了。</p><h3 id="什么是类型保护？"><a href="#什么是类型保护？" class="headerlink" title="什么是类型保护？"></a>什么是类型保护？</h3><p>要知道类型保护，首先要知道 <code>联合类型（Union Types）</code>，<br>现有如下需求：</p><ul><li>需要一个返回 用户 信息的方法</li><li>这个方法支持用id 查询 也支持 用姓名查询，id类型为 name 姓名 类型 为string</li><li>id 查询会返回带有id 不带 name的对象信息</li><li>name查询会返回有 name 不带id的对象信息</li></ul><p>这个需求中 我们查询参数需要用到 联合类型，返回参数也需要</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> UserId = &#123;<br>    id: <span class="hljs-built_in">number</span>,<br>    age: <span class="hljs-built_in">number</span>,<br>&#125;<br><br><span class="hljs-keyword">type</span> UserName = &#123;<br>    name: <span class="hljs-built_in">string</span>,<br>    age: <span class="hljs-built_in">number</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserInfo</span> (<span class="hljs-params">token: <span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span></span>): <span class="hljs-title">UserId</span> | <span class="hljs-title">UserName</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> token === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            name: token,<br>            age: <span class="hljs-number">123</span>,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        id: token,<br>        age: <span class="hljs-number">123</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(getUserInfo(<span class="hljs-number">1</span>)); <span class="hljs-comment">// &#123; id: 1, age: 123 &#125;</span><br><span class="hljs-built_in">console</span>.log(getUserInfo(<span class="hljs-string">&#x27;test&#x27;</span>)); <span class="hljs-comment">// &#123; name: &#x27;test&#x27;, age: 123 &#125;</span><br></code></pre></td></tr></table></figure><p>现在方法已经写好 咱们要使用这个方法来进行查询 来判断 是否有id 或者name</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 报错信息为</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">类型“UserId | UserName”上不存在属性“id”。</span><br><span class="hljs-comment">  类型“UserName”上不存在属性“id”。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span> (getUserInfo(<span class="hljs-number">1</span>).id) &#123;<br>    <span class="hljs-built_in">console</span>.log(getUserInfo(<span class="hljs-number">1</span>).id)<br>&#125;<br><br><span class="hljs-comment">// 报错信息为</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">类型“UserId | UserName”上不存在属性“name”。</span><br><span class="hljs-comment">  类型“UserId”上不存在属性“name”。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span> (getUserInfo(<span class="hljs-string">&#x27;test&#x27;</span>).name) &#123;<br>     <span class="hljs-built_in">console</span>.log(getUserInfo(<span class="hljs-string">&#x27;test&#x27;</span>).name)<br>&#125;<br>    <br></code></pre></td></tr></table></figure><p>上面的报错有问题吗？没问题，因为在你使用联合类型时，ts无法判断你代码未运行的结果，所以进行进行报错，那应该怎么处理？这时候 就需要 <code>类型保护 type guards</code></p><h3 id="类型保护怎么写？"><a href="#类型保护怎么写？" class="headerlink" title="类型保护怎么写？"></a>类型保护怎么写？</h3><p>针对以上代码进行处理如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> ((&lt;UserId&gt;getUserInfo(<span class="hljs-number">1</span>)).id) &#123;<br>    <span class="hljs-built_in">console</span>.log((&lt;UserId&gt;getUserInfo(<span class="hljs-number">1</span>)).id)<br>&#125;<br>    <br><span class="hljs-keyword">if</span> ((&lt;UserName&gt;getUserInfo(<span class="hljs-string">&#x27;test&#x27;</span>)).name) &#123;<br>    <span class="hljs-built_in">console</span>.log((&lt;UserId&gt;getUserInfo(<span class="hljs-string">&#x27;test&#x27;</span>)).name)<br>&#125;<br></code></pre></td></tr></table></figure><p>当你在<code>if</code>语句中告知该函数返回类型时，这样就不会报错 但是 有些麻烦 ，所以咱们使用自定义的类型保护</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUserId</span>(<span class="hljs-params">obj: UserName|UserId</span>):<span class="hljs-title">obj</span> <span class="hljs-title">is</span> <span class="hljs-title">UserId</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (&lt;UserId&gt;obj).id !== <span class="hljs-literal">undefined</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUserName</span>(<span class="hljs-params">obj: UserName|UserId</span>):<span class="hljs-title">obj</span> <span class="hljs-title">is</span> <span class="hljs-title">UserName</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (&lt;UserName&gt;obj).name !== <span class="hljs-literal">undefined</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> idObj = getUserInfo(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> nameObj = getUserInfo(<span class="hljs-string">&#x27;test&#x27;</span>);<br><br><span class="hljs-keyword">if</span>(isUserId(idObj)) &#123;<br>    <span class="hljs-built_in">console</span>.log(idObj.id);<br>&#125;<br><br><span class="hljs-keyword">if</span>(isUserName(nameObj)) &#123;<br>    <span class="hljs-built_in">console</span>.log(nameObj.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样 就可以 使用 自定义的类型保护 ，来保证TS类型检查 在检查联合类型不会报错，而且会按照预期的类型提示</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.tslang.cn/docs/handbook/advanced-types.html">高级类型 · TypeScript中文网 · TypeScript——JavaScript的超集</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器中的页面</title>
    <link href="/sevenflow.blog/2021/09/15/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2/"/>
    <url>/sevenflow.blog/2021/09/15/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器中的页面"><a href="#浏览器中的页面" class="headerlink" title="浏览器中的页面"></a>浏览器中的页面</h1><h2 id="Chrome开发者工具：利用网络面板做性能分析"><a href="#Chrome开发者工具：利用网络面板做性能分析" class="headerlink" title="Chrome开发者工具：利用网络面板做性能分析"></a>Chrome开发者工具：利用网络面板做性能分析</h2><h3 id="chrome开发工具"><a href="#chrome开发工具" class="headerlink" title="chrome开发工具"></a>chrome开发工具</h3><ul><li>性能相关<ul><li>网络面板</li><li>performance</li><li>内存面板</li></ul></li><li>调试页面<ul><li>Elements</li><li>Sources</li><li>Console</li></ul></li></ul><p>…</p><p><img src="https://static001.geekbang.org/resource/image/c5/82/c5eb9603e79547ae3d815254e24d4782.png" alt="img"></p><h4 id="网络面板"><a href="#网络面板" class="headerlink" title="网络面板"></a>网络面板</h4><p><img src="https://static001.geekbang.org/resource/image/46/57/46fba54f54b9bd43918308f9f1ae1357.png" alt="img"></p><ul><li><p>控制器</p><ul><li><img src="https://static001.geekbang.org/resource/image/f0/42/f02477088c0499247e0ed37f46ad2a42.png" alt="img"></li><li>红色圆点的按钮，表示“开始 / 暂停抓包”，这个功能很常见，很容易理解。</li><li>“全局搜索”按钮，这个功能就非常重要了，可以在所有下载资源中搜索相关内容，还可以快速定位到某几个你想要的文件上。</li><li>Disable cache，即“禁止从 Cache 中加载资源”的功能，它在调试 Web 应用的时候非常有用，因为开启了 Cache 会影响到网络性能测试的结果。</li><li>Online 按钮，是“模拟 2G/3G”功能，它可以限制带宽，模拟弱网情况下页面的展现情况，然后你就可以根据实际展示情况来动态调整策略，以便让 Web 应用更加适用于这些弱网。</li></ul></li><li><p>过滤器</p><ul><li>网络面板中的过滤器，主要就是起过滤功能。因为有时候一个页面有太多内容在详细列表区域中展示了，而你可能只想查看 JavaScript 文件或者 CSS 文件，这时候就可以通过过滤器模块来筛选你想要的文件类型。</li></ul></li><li><p>抓图信息</p><ul><li>抓图信息区域，可以用来分析用户等待页面加载时间内所看到的内容，分析用户实际的体验情况。比如，如果页面加载 1 秒多之后屏幕截图还是白屏状态，这时候就需要分析是网络还是代码的问题了。（勾选面板上的“Capture screenshots”即可启用屏幕截图。）</li></ul></li><li><p>时间线</p><ul><li>时间线，主要用来展示 HTTP、HTTPS、WebSocket 加载的状态和时间的一个关系，用于直观感受页面的加载过程。如果是多条竖线堆叠在一起，那说明这些资源被同时被加载。至于具体到每个文件的加载信息，还需要用到下面要讲的详细列表。</li></ul></li><li><p>详细列表</p><ul><li>这个区域是最重要的，它详细记录了每个资源从发起请求到完成请求这中间所有过程的状态，以及最终请求完成的数据信息。通过该列表，你就能很容易地去诊断一些网络问题。</li></ul></li><li><p>下载信息</p><ul><li>下载信息概要中，你要重点关注下 DOMContentLoaded 和 Load 两个事件，以及这两个事件的完成时间。</li><li>DOMContentLoaded，这个事件发生后，说明页面已经构建好 DOM 了，这意味着构建 DOM 所需要的 HTML 文件、JavaScript 文件、CSS 文件都已经下载完成了。</li><li>Load，说明浏览器已经加载了所有的资源（图像、样式表等）。</li></ul></li></ul><p>通过下载信息概要面板，你可以查看触发这两个事件所花费的时间。</p><h4 id="网络面板中的详细列表"><a href="#网络面板中的详细列表" class="headerlink" title="网络面板中的详细列表"></a>网络面板中的详细列表</h4><ul><li><p>列表属性</p><ul><li><img src="https://static001.geekbang.org/resource/image/7b/81/7b296e168a4900d3b5cb8e57cc3f6181.png" alt="img"></li></ul></li><li><p>详细信息</p><ul><li><img src="https://static001.geekbang.org/resource/image/f7/e6/f76ee3b6b2e6e9629efdd01e6ded57e6.png" alt="img" style="zoom:200%;" /></li></ul></li><li><p>单个资源的时间线</p><ul><li><p>涉及到HTTP请求流程了</p><ul><li><img src="https://static001.geekbang.org/resource/image/1f/e0/1f4f8c194b02975f6d2848b7b73175e0.png" alt="img"></li></ul></li><li><p>示例Timing</p><p><img src="https://static001.geekbang.org/resource/image/ba/af/ba91f06503bda4b4dc4a54901bd7a8af.png" alt="img"></p></li><li><p>Queuing</p><ul><li>也就是排队的意思，当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待。导致请求处于排队状态的原因有很多。</li><li>首先，页面中的资源是有优先级的，比如 CSS、HTML、JavaScript 等都是页面中的核心文件，所以优先级最高；而图片、视频、音频这类资源就不是核心资源，优先级就比较低。通常当后者遇到前者时，就需要“让路”，进入待排队状态。</li><li>其次，我们前面也提到过，浏览器会为每个域名最多维护 6 个 TCP 连接，如果发起一个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态。</li><li>最后，网络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。</li></ul></li><li><p>Stalled</p><ul><li>等待排队完成之后，就要进入发起连接的状态了。不过在发起连接之前，还有一些原因可能导致连接过程被推迟，这个推迟就表现在面板中的 Stalled 上，它表示停滞的意思。</li></ul></li><li><p>Proxy Negotiation</p><ul><li>这里需要额外说明的是，如果你使用了代理服务器，还会增加一个 Proxy Negotiation 阶段，也就是代理协商阶段，它表示代理服务器连接协商所用的时间，</li></ul></li><li><p>Initial connection/SSL 阶段</p><ul><li>和服务器建立连接的阶段，这包括了建立 TCP 连接所花费的时间；不过如果你使用了 HTTPS 协议，那么还需要一个额外的 SSL 握手时间，这个过程主要是用来协商一些加密信息的。</li></ul></li><li><p>Request sent</p><ul><li>和服务器建立好连接之后，网络进程会准备请求数据，并将其发送给网络，通常这个阶段非常快，因为只需要把浏览器缓冲区的数据发送出去就结束了，并不需要判断服务器是否接收到了，所以这个时间通常不到 1 毫秒。</li></ul></li><li><p>waiting</p><ul><li>数据发送出去了，接下来就是等待接收服务器第一个字节的数据，这个阶段称为 Waiting (TTFB)，通常也称为“第一字节时间”，TTFB 是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明服务器响应越快。</li></ul></li><li><p>Content Download</p><ul><li>接收到第一个字节之后，进入陆续接收完整数据的阶段，也就是 Content Download 阶段，这意味着从第一字节时间到接收到全部响应数据所用的时间。</li></ul></li></ul></li></ul><h3 id="优化时间线上耗时项"><a href="#优化时间线上耗时项" class="headerlink" title="优化时间线上耗时项"></a>优化时间线上耗时项</h3><ul><li>排队（Queuing）时间过久<ul><li>域名分片技术<ul><li>排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。那么基于这个原因，你就可以让 1 个站点下面的资源放在多个域名下面，比如放到 3 个域名下面，这样就可以同时支持 18 个连接了，这种方案称为域名分片技术。除了域名分片技术外，我个人还建议你把站点升级到 HTTP2，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了。</li></ul></li></ul></li><li>第一字节时间（TTFB）时间过久<ul><li>服务器生成页面数据的时间过久<ul><li>对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户。服务器在处理这个数据的过程中，可能某个环节会出问题。</li><li>处理就是提示服务器处理速度，增加缓存技术</li></ul></li><li>网络的原因<ul><li>网络请求过慢，利用CDN来缓存静态文件</li></ul></li><li>发送请求头时带上了多余的用户信息<ul><li>比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长。</li></ul></li></ul></li><li>Content Download 时间过久<ul><li>如果单个请求的 Content Download 花费了大量时间，有可能是字节数太多的原因导致的。这时候你就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。</li></ul></li></ul><h2 id="DOM树：JavaScript是如何影响DOM树构建的？"><a href="#DOM树：JavaScript是如何影响DOM树构建的？" class="headerlink" title="DOM树：JavaScript是如何影响DOM树构建的？"></a>DOM树：JavaScript是如何影响DOM树构建的？</h2><h3 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h3><ul><li>从页面的视角来看，DOM 是生成页面的基础数据结构。</li><li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。</li><li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。</li></ul><h3 id="DOM树如何生成"><a href="#DOM树如何生成" class="headerlink" title="DOM树如何生成"></a>DOM树如何生成</h3><blockquote><p>由HTML解析器 转换的DOM结构</p></blockquote><ul><li><p>HTML 解析器是等整个 HTML 文档加载完成之后开始解析的，还是随着 HTML 文档边加载边解析的？</p><p>HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。</p></li></ul><h4 id="DOM网络到解析流程"><a href="#DOM网络到解析流程" class="headerlink" title="DOM网络到解析流程"></a>DOM网络到解析流程</h4><ul><li><p>网络进程接受到响应头为 content-type 的值是“text/html”</p></li><li><p>创建渲染进程</p></li><li><p>渲染进程准备好后，网络进程和渲染进程之间会建立一个共享数据的管道</p><p>然后是解析DOM</p></li></ul><h4 id="字节流转换DOM"><a href="#字节流转换DOM" class="headerlink" title="字节流转换DOM"></a>字节流转换DOM</h4><p>如下图</p><p><img src="https://static001.geekbang.org/resource/image/1b/8c/1bfcd419acf6402c20ffc1a5b1909d8c.png" alt="img"></p><ul><li>第一步，通过分词器将字节流转换为Token，如下</li></ul><p><img src="https://static001.geekbang.org/resource/image/b1/ac/b16d2fbb77e12e376ac0d7edec20ceac.png" alt="img"></p><ul><li><p>第二步和第三步同步进行，将Token解析为DOM节点，并将DOM节点添加到DOM树中</p><p>HTML解析器维护了一个Token栈结构，该Token栈主要用来计算节点之间的父子关系规则如下</p><ul><li>压入栈中的是StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li><li>如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li><li>如果分词器解析出来的是 EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。</li></ul><p>通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。</p><p>这里需要补充说明下，HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/7a/f1/7a6cd022bd51a3f274cd994b1398bef1.png" alt="img"></p></li></ul><h3 id="JS是如何影响到DOM生成的"><a href="#JS是如何影响到DOM生成的" class="headerlink" title="JS是如何影响到DOM生成的"></a>JS是如何影响到DOM生成的</h3><p>代码如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> div1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>]</span><br><span class="javascript">    div1.innerText = <span class="hljs-string">&#x27;time.geekbang&#x27;</span></span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>DOM解析器遇见 <code>&lt;script&gt;</code>标签汇停止解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。</p><ul><li>暂停解析</li><li>执行脚本</li><li>修改DOM元素，执行完成</li><li>继续解析DOM</li><li>生成DOM对象</li></ul><p>如果是内嵌还好，但是如果是引入的文件比较复杂 ，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//foo.js</span><br><span class="hljs-keyword">let</span> div1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>]<br>div1.innerText = <span class="hljs-string">&#x27;time.geekbang&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;foo.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>DOM解析流程变为</p><ul><li><p>暂停执行</p></li><li><p>执行下载文件，JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</p></li><li><p>接下来就是正常解析</p><p>chrome优化，</p><ul><li>主要优化是<code>预解析操作</code>，当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</li></ul><p>自己优化</p><ul><li><p>放入CDN加速，压缩JS文件体积</p></li><li><p>JS文件中没有操作DOM相关代码，可以设置为异步加载 通过 <code>asyns</code> or <code>defer</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;foo.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;foo.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>差异是：</p><p>async：脚本并行加载，加载完成之后立即执行，执行时机不确定，仍有可能阻塞HTML解析，执行时机在load事件派发之前</p><p>defer：脚本并行加载，等待HTML解析完成之后，按照加载顺序执行脚本，执行时机在DOMContentLoaded事件派发之前</p></li></ul></li><li><p>如果遇见JS修改CSS呢 ？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;theme.css&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">            <span class="hljs-keyword">let</span> div1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>]</span><br><span class="javascript">            div1.innerText = <span class="hljs-string">&#x27;time.geekbang&#x27;</span> <span class="hljs-comment">//需要DOM</span></span><br><span class="javascript">            div1.style.color = <span class="hljs-string">&#x27;red&#x27;</span>  <span class="hljs-comment">//需要CSSOM</span></span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。</li><li>而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。</li></ul></li></ul><h2 id="渲染流水线：CSS如何影响首次加载时的白屏时间？"><a href="#渲染流水线：CSS如何影响首次加载时的白屏时间？" class="headerlink" title="渲染流水线：CSS如何影响首次加载时的白屏时间？"></a>渲染流水线：CSS如何影响首次加载时的白屏时间？</h2><h3 id="渲染流水线视角下的-CSS"><a href="#渲染流水线视角下的-CSS" class="headerlink" title="渲染流水线视角下的 CSS"></a>渲染流水线视角下的 CSS</h3><ul><li>渲染流水线示意图</li></ul><p><img src="https://static001.geekbang.org/resource/image/70/18/70a7ea0212ff35fc2be79f1d574ed518.png" alt="img"></p><ul><li>首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行</li><li>网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM<ul><li>这里你需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。</li></ul></li><li>渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据</li><li>css文件未下载成功，但是DOM树构建已完成，浏览器就会有空闲时间，渲染流水线无事可做，因为下一步是合成布局树，合成需要DOM与CSSOM，所以需要等待</li></ul><h3 id="那渲染流水线为什么需要-CSSOM-呢？"><a href="#那渲染流水线为什么需要-CSSOM-呢？" class="headerlink" title="那渲染流水线为什么需要 CSSOM 呢？"></a>那渲染流水线为什么需要 CSSOM 呢？</h3><blockquote><p>渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。</p></blockquote><ul><li><p>作用</p><ul><li>提供给 JavaScript 操作样式表的能力</li><li>为布局树的合成提供基础的样式信息</li></ul></li><li><p>复杂场景代码如下</p><p>theme.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123; <br>    <span class="hljs-attribute">color </span>: coral;<br>    <span class="hljs-attribute">background-color</span>:black<br>&#125;<br></code></pre></td></tr></table></figure><p>html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;theme.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>geekbang com<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;time.geekbang.org&#x27;</span>)</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>geekbang com<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>渲染流水</p><p><img src="https://static001.geekbang.org/resource/image/f8/1c/f85f8778f273710ca559a52027ed731c.png" alt="img"></p><p>可以看到比之前只有css和dom的渲染多了JS的加入，导致DOM解析受阻，所以页面也堵塞。</p><p>如果JS有操作CSS，那么cssom也会解析受阻，从而页面堵塞。</p></li><li><p>更复杂场景</p><p>foo.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;time.geekbang.org&#x27;</span>)<br></code></pre></td></tr></table></figure><p>html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;theme.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>geekbang com<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;foo.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>geekbang com<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>渲染流水如下</p><p><img src="https://static001.geekbang.org/resource/image/76/1f/7641c75a80133e747aa2faae8f4c8d1f.png" alt="img"></p></li></ul><h3 id="影响页面展示的因素以及优化策略"><a href="#影响页面展示的因素以及优化策略" class="headerlink" title="影响页面展示的因素以及优化策略"></a>影响页面展示的因素以及优化策略</h3><blockquote><p>渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验</p></blockquote><ul><li>第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容<ul><li>主要是服务器处理这块</li></ul></li><li>第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。<ul><li>通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。</li><li>要想缩短白屏时长，可以有以下策略：<ul><li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li><li>但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。</li><li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。</li><li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li></ul></li></ul></li><li>第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。</li></ul><h2 id="分层和合成机制：为什么CSS动画比JavaScript高效？"><a href="#分层和合成机制：为什么CSS动画比JavaScript高效？" class="headerlink" title="分层和合成机制：为什么CSS动画比JavaScript高效？"></a>分层和合成机制：为什么CSS动画比JavaScript高效？</h2><h3 id="显示器是怎么显示图像的"><a href="#显示器是怎么显示图像的" class="headerlink" title="显示器是怎么显示图像的"></a>显示器是怎么显示图像的</h3><blockquote><p>每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫前缓冲区的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。</p></blockquote><h4 id="那么这里显卡做什么呢？"><a href="#那么这里显卡做什么呢？" class="headerlink" title="那么这里显卡做什么呢？"></a>那么这里显卡做什么呢？</h4><p> 显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。</p><h3 id="帧-VS-帧率"><a href="#帧-VS-帧率" class="headerlink" title="帧 VS 帧率"></a>帧 VS 帧率</h3><ul><li>页面滚动时是渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。</li><li>大多数设备屏幕的更新频率是 60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。</li><li>我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。</li><li>由于用户很容易观察到那些丢失的帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿，这会给用户造成非常不好的印象。</li><li>要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了<code>分层</code>和<code>合成机制</code>。分层和合成机制代表了当今最先进的渲染技术</li></ul><h3 id="如何生成一帧图像"><a href="#如何生成一帧图像" class="headerlink" title="如何生成一帧图像"></a>如何生成一帧图像</h3><p>其中任意一帧的生成方式，有<code>重排</code>、<code>重绘</code>和<code>合成</code>三种方式，这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。</p><ul><li>重排<ul><li>需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了</li></ul></li><li>重绘<ul><li>没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。</li></ul></li><li>合成<ul><li>不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高</li></ul></li></ul><p>按照效率我们推荐合成方式优先，若实在不能满足需求，那么就再退后一步使用重绘或者重排的方式。</p><h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><blockquote><p>Chrome 中的合成技术，可以用三个词来概括总结：分层、分块和合成。</p></blockquote><h4 id="分层和合成"><a href="#分层和合成" class="headerlink" title="分层和合成"></a>分层和合成</h4><p>如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率。</p><blockquote><p>为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制</p></blockquote><ul><li><p>分层</p><p>类似于PS的图层，将素材分解为多个图层的操作就称为分层</p></li><li><p>合成</p><p>将这些图层合并到一起的操作就称为合成</p></li></ul><p>分层和合成通常是一起使用的。</p><h3 id="Chrome-是怎么实现分层和合成机制的。"><a href="#Chrome-是怎么实现分层和合成机制的。" class="headerlink" title="Chrome 是怎么实现分层和合成机制的。"></a>Chrome 是怎么实现分层和合成机制的。</h3><p>在 Chrome 的渲染流水线中，<code>分层体现在生成布局树之后</code>，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。</p><ul><li>层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点</li><li>绘制是执行指令列表, </li><li>有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。</li><li>每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。</li><li>合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。</li></ul><h3 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h3><p>如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。</p><ul><li>页面过大，把页面分为优先级高低的几块，先渲染优先级高的<ul><li>即使是这样，也会耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。</li></ul></li><li>为了解决这个问题，Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。<ul><li>比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。</li><li>这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。</li></ul></li></ul><h3 id="如何利用分层技术优化代码"><a href="#如何利用分层技术优化代码" class="headerlink" title="如何利用分层技术优化代码"></a>如何利用分层技术优化代码</h3><p>在写 Web 应用的时候，你可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。</p><p>这时你可以使用<code> will-change</code> 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>will-change: transform, opacity; // 这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>JS动画会占用渲染主线程，而CSS动画是合成线程所以 CSS 动画比 JavaScript 动画高效</li><li>如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层<ul><li>每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。</li></ul></li></ul><h2 id="如何系统的优化页面"><a href="#如何系统的优化页面" class="headerlink" title="如何系统的优化页面"></a>如何系统的优化页面</h2><blockquote><p>这里我们所谈论的页面优化，其实就是要让页面更快地显示和响应</p></blockquote><p>由于一个页面在它不同的阶段，所侧重的关注点是不一样的，所以如果我们要讨论页面优化，就要分析一个页面生存周期的不同阶段。</p><ul><li>加载阶段 ，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。</li><li>交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。</li><li>关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。</li></ul><p>重点关注加载阶段和交互阶段</p><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p>典型的渲染流水线</p><p><img src="https://static001.geekbang.org/resource/image/5d/7b/5d8716586b5f4d719097dca881007a7b.jpg" alt="img"></p><p>把阻塞首次绘制的资源称为关键资源，比如JS文件，css文件，首次请求的HTML文件</p><p>图片，音频，视频是不堵塞的</p><p>根据关键资源可以细化三个首次渲染的核心因素</p><ul><li>关键资源个数</li><li>关键资源大小</li><li>关键资源需要多少个RTT（Round Trip Time）<ul><li>比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的</li><li>RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延</li><li>通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。</li></ul></li></ul><p>优化方案原则</p><ul><li>减少关键资源个数<ul><li>将JS与css改为内联的形式</li><li>JS没有DOM或者CSSOM操作，改为async或者defer属性，变为非关键资源</li><li>css不是在构建页面之前需要加载的，也可以添加媒体筛选</li></ul></li><li>降低关键资源大小<ul><li>压缩css和JS资源，移除注释</li></ul></li><li>减低关键资源的RTT次数<ul><li>可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。</li><li>还可以使用 CDN 来减少每次 RTT 时长。</li></ul></li></ul><h3 id="交互阶段"><a href="#交互阶段" class="headerlink" title="交互阶段"></a>交互阶段</h3><p>谈交互阶段的优化，其实就是在谈渲染进程渲染帧的速度，因为在交互阶段，帧的渲染速度决定了交互的流畅度。因此讨论页面优化实际上就是讨论渲染引擎是如何渲染帧的，否则就无法优化帧率。</p><p>交互阶段的渲染流水线</p><p><img src="https://static001.geekbang.org/resource/image/4a/0c/4a942e53f9358c9c4634c310335cc10c.png" alt="img"></p><p>如何生成一帧？</p><ul><li>JS修改DOM或者CSSOM来触发的</li><li>CSS来触发</li></ul><h4 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h4><p>原则：让单个帧的生成速度变快</p><ul><li><p>减少 JavaScript 脚本执行时间</p><ul><li>一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久</li><li>另一种是采用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers">Web Workers</a></li></ul></li><li><p>避免强制同步布局</p><ul><li><p>普通布局，先计算执行JS，然后布局</p><ul><li><pre><code class="html">&lt;html&gt;&lt;body&gt;    &lt;div id=&quot;mian_div&quot;&gt;        &lt;li id=&quot;time_li&quot;&gt;time&lt;/li&gt;        &lt;li&gt;geekbang&lt;/li&gt;    &lt;/div&gt;    &lt;p id=&quot;demo&quot;&gt;强制布局demo&lt;/p&gt;    &lt;button onclick=&quot;foo()&quot;&gt;添加新元素&lt;/button&gt;    &lt;script&gt;        function foo() &#123;            let main_div = document.getElementById(&quot;mian_div&quot;)                  let new_node = document.createElement(&quot;li&quot;)            let textnode = document.createTextNode(&quot;time.geekbang&quot;)            new_node.appendChild(textnode);            document.getElementById(&quot;mian_div&quot;).appendChild(new_node);        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>  - !<span class="hljs-literal">[<span class="hljs-identifier">img</span>]</span>(https:<span class="hljs-comment">//static001.geekbang.org/resource/image/32/c9/32b6a645646f99fc3517fb0b5e003cc9.png)</span><br><br>  - 执行 JavaScript 添加元素是在一个任务中执行的，重新计算样式布局是在另外一个任务中执行<br><br>- 强制布局，执行JS中进行布局，然后继续执行一段JS<br><br>  - 是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中<br><br>  - ```js<br>    <br>    <span class="hljs-keyword">function</span> foo<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-keyword">let</span> main_div = document.get<span class="hljs-constructor">ElementById(<span class="hljs-string">&quot;mian_div&quot;</span>)</span><br>        <span class="hljs-keyword">let</span> new_node = document.create<span class="hljs-constructor">Element(<span class="hljs-string">&quot;li&quot;</span>)</span><br>        <span class="hljs-keyword">let</span> textnode = document.create<span class="hljs-constructor">TextNode(<span class="hljs-string">&quot;time.geekbang&quot;</span>)</span><br>        new_node.append<span class="hljs-constructor">Child(<span class="hljs-params">textnode</span>)</span>;<br>        document.get<span class="hljs-constructor">ElementById(<span class="hljs-string">&quot;mian_div&quot;</span>)</span>.append<span class="hljs-constructor">Child(<span class="hljs-params">new_node</span>)</span>;<br>        <span class="hljs-comment">//由于要获取到offsetHeight，</span><br>        <span class="hljs-comment">//但是此时的offsetHeight还是老的数据，</span><br>        <span class="hljs-comment">//所以需要立即执行布局操作</span><br>        console.log(main_div.offsetHeight)<br>    &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>将新的元素添加到 DOM 之后，我们又调用了main_div.offsetHeight来获取新 main_div 的高度信息。如果要获取到 main_div 的高度，就需要重新布局，所以这里在获取到 main_div 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。我们把这个操作称为强制同步布局。</p></li></ul></li></ul></li><li><p>避免布局抖动</p><ul><li><p>指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作</p></li><li><pre><code class="js">function foo() &#123;    let time_li = document.getElementById(&quot;time_li&quot;)    for (let i = 0; i &lt; 100; i++) &#123;        let main_div = document.getElementById(&quot;mian_div&quot;)        let new_node = document.createElement(&quot;li&quot;)        let textnode = document.createTextNode(&quot;time.geekbang&quot;)        new_node.appendChild(textnode);        new_node.offsetHeight = time_li.offsetHeight;        document.getElementById(&quot;mian_div&quot;).appendChild(new_node);    &#125;&#125;<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>  - 我们在一个 for 循环语句里面不断读取属性值，每次读取属性值之前都要进行计算样式和布局。执行代码之后，使用 Performance 记录的状态如下所示：<br><br>    ![img](https://static001.geekbang.org/resource/image/36/87/36159f7081e37ce4714b20ce2630e987.png)<br><br>  - 尽量不要在修改 DOM 结构时再去查询一些相关值。<br><br>- 合理利用css合成动画<br><br>  - 合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行<br>  - 如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。<br><br>- 避免频繁的垃圾回收<br><br>  - 如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。避免这种小颗粒对象产生<br><br>## 虚拟DOM：虚拟DOM 和实际的DOM有何不同<br><br>&gt; 先聊聊DOM的缺陷，说一下虚拟DOM怎么解决这些缺陷的，最后再站在双缓存和 MVC 的视角来聊聊虚拟 DOM<br><br>### DOM缺陷<br><br>- JS操控DOM会影响整个渲染流水线，会引起**重排**，**重绘**或者**合成**操作，还有可能引起**强制同步布局**和**布局抖动**，从而降低渲染效率<br>- 复杂页面DOM结构复杂，所生成的页面结构也复杂，每次重排之类的很耗时，所以有性能问题<br><br>而虚拟DOM可以减少这些问题<br><br>### 什么是虚拟DOM<br><br>#### 虚拟DOM需要解决什么？<br><br>- 将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。<br>- 变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。<br>- 在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。<br><br>![img](https://static001.geekbang.org/resource/image/cf/90/cf2089ad62af94881757c2f2de277890.png)<br><br>#### 虚拟DOM运行<br><br>主要是React<br><br>- 创建阶段<br>  - 根据JSX结构和基础数据构成虚拟DOM的数据，然后虚拟DOM创建出真实的DOM树，然后触发渲染<br>- 更新阶段<br>  - 数据改变，创建新的虚拟DOM树，然后对比之前旧的，只拿到改变的地方然后更新真实DOM<br><br>**React的Fiber更新机制**<br><br>- 更新主要是由对比后引起的，而对比之前的算法为**Stack reconciler**，当虚拟DOM复杂时会比较耗时，占据主线程比较久的时间<br>- 新算法为**Fiber reconciler**，类似于协程，其实协程的另一个称呼就是Fiber，就是在执行算法的过程中出让主线程，这样就解决了 Stack reconciler 函数占用时间过久的问题。<br><br>### 双缓冲<br><br>其实是一个概念，类似于 显卡创造出的前缓存区和后缓存区，显示器只读取前缓存区，读取完后再换后缓存区到前缓存区。<br><br>那么虚拟DOM相当于一个真实DOM的一个buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。<br><br>### MVC模式<br><br>* MVC模式<br><br>  ![img](https://static001.geekbang.org/resource/image/4c/a6/4c03b5882878dcce2df01c1e2e8db8a6.png)<br><br>  - 核心思想就是将数据和视图分离，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的<br><br>* react下的MVC<br><br>  * ![img](https://static001.geekbang.org/resource/image/e0/03/e024ba6c212a1d6bfa01b327e987e103.png)<br>  * 图中的控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据<br>  * 模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；<br>  * 视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；<br>  * 新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；<br>  * 比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；<br>  * DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新。<br><br>## 渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？<br><br>- web应用开发者<br>  - PWA 提供了一个渐进式的过渡方案，让 Web 应用能逐步具有本地应用的能力。采取渐进式可以降低站点改造的代价，使得站点逐步支持各项新技术，而不是一步到位<br>- 技术角度<br>  - PWA 技术也是一个渐进式的演化过程，在技术层面会一点点演进，比如逐渐提供更好的设备特性支持，不断优化更加流畅的动画效果，不断让页面的加载速度变得更快，不断实现本地应用的特性。<br>- 定义<br>  - 它是一套理念，渐进式增强 Web 的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离。基于这套理念之下的技术都可以归类到 PWA。<br><br>### web应用VS本地应用<br><br>web页面缺少什么？<br><br>- 离线能力，导致用户无法沉浸式体验<br>- 缺少消息推送的能力，作为一个 App 厂商，需要有将消息送达到应用的能力。<br>- 缺少一级入口，无法直接将应用放置在桌面，都需要浏览器打开<br><br>针对以上 Web 缺陷，PWA 提出了两种解决方案：通过引入 Service Worker 来试着解决离线存储和消息推送的问题，通过引入 manifest.json 来解决一级入口的问题。<br><br>### Service Worker<br><br>思想<br><br>- 在页面和网络之间增加一个拦截器，用来缓存和拦截请求<br><br>![img](https://static001.geekbang.org/resource/image/23/12/23b97b087c346cdd378b26b2d158e812.png)<br><br>#### Service Worker 的设计思路<br><br>- 架构<br>  - “让其运行在主线程之外”就是 Service Worker 来自 Web Worker 的一个核心思想。<br>    - 主要是不能影响JS主流程的<br>  - Service Worker 和单个页面绑定起来，在目前的 Chrome 架构中，Service Worker 是运行在浏览器进程中的，因为浏览器进程生命周期是最长的，所以在浏览器的生命周期内，能够为所有的页面提供服务。<br>    - 需要为多个页面提供服务<br>- 消息推送<br>  - 消息推送也是基于 Service Worker 来实现的<br>    - 因为消息推送时，浏览器页面也许并没有启动（和刚才的主线程以及浏览器进程就连接上了），这时就需要 Service Worker 来接收服务器推送的消息，并将消息通过一定方式展示给用户。<br><br>- 安全<br>  - HTTP为明文传输，所以要使站点支持 Service Worker，首先必要的一步就是要将站点升级到 HTTPS。<br>  - 还需要同时支持 Web 页面默认的安全策略，诸如同源策略、内容安全策略（CSP）等<br><br>## WebComponent：像搭积木一样构建Web应用<br><br>组件化要求<br><br>- 对内高内聚，对外低耦合<br><br>### 阻碍前端组件化的因素<br><br>- css的全局影响性<br>- DOM在JS操作下可全局修改的问题<br><br>### webComponent组件化开发<br><br>官方给的组合技术 是 Custom elements（自定义元素）、Shadow DOM（影子 DOM）和HTML templates（HTML 模板），代码如下<br><br>```html<br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            一：定义模板</span><br><span class="hljs-comment">            二：定义内部CSS样式</span><br><span class="hljs-comment">            三：定义JavaScript行为</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;geekbang-t&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>            p &#123;<br>                background-color: brown;<br>                color: cornsilk<br>            &#125;<br><br><br>            div &#123;<br>                width: 200px;<br>                background-color: bisque;<br>                border: 3px solid chocolate;<br>                border-radius: 10px;<br>            &#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>time.geekbang.org<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>time1.geekbang.org<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;inner log&#x27;</span>)</span><br>            &#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeekBang</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>&#123;</span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">super</span>()</span><br><span class="javascript">                <span class="hljs-comment">//获取组件模板</span></span><br><span class="javascript">                <span class="hljs-keyword">const</span> content = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#geekbang-t&#x27;</span>).content</span><br><span class="javascript">                <span class="hljs-comment">//创建影子DOM节点</span></span><br><span class="javascript">                <span class="hljs-keyword">const</span> shadowDOM = <span class="hljs-built_in">this</span>.attachShadow(&#123; <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;open&#x27;</span> &#125;)</span><br><span class="javascript">                <span class="hljs-comment">//将模板添加到影子DOM上</span></span><br><span class="javascript">                shadowDOM.appendChild(content.cloneNode(<span class="hljs-literal">true</span>))</span><br>            &#125;<br>        &#125;<br><span class="javascript">        customElements.define(<span class="hljs-string">&#x27;geek-bang&#x27;</span>, GeekBang)</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">geek-bang</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">geek-bang</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>time.geekbang.org<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>time1.geekbang.org<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">geek-bang</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">geek-bang</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><ul><li>template来创建模板</li><li>在模板中创建一个类<ul><li>获取到当前模板元素</li><li>创建影子DOM</li><li>再将模板添加到影子DOM上</li></ul></li><li>在HTML中使用这个自定义标签</li></ul><h3 id="浏览器如何实现影子DOM"><a href="#浏览器如何实现影子DOM" class="headerlink" title="浏览器如何实现影子DOM"></a>浏览器如何实现影子DOM</h3><p>影子DOM作用</p><ul><li>shadowDom对于整个网页不可见</li><li>shadowDom的css不影响整个网页的CSSOM，影子DOM内部只影响内部元素</li></ul><p>浏览器如何实现shadowDom？</p><p><img src="https://static001.geekbang.org/resource/image/5b/22/5bce3d00c8139a7fde9cc90f9d803322.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器工作原理与实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器中JS的执行机制</title>
    <link href="/sevenflow.blog/2021/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%ADJS%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/sevenflow.blog/2021/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%ADJS%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器中JS的执行机制"><a href="#浏览器中JS的执行机制" class="headerlink" title="浏览器中JS的执行机制"></a>浏览器中JS的执行机制</h1><h2 id="JS代码是按照顺序执行的吗？"><a href="#JS代码是按照顺序执行的吗？" class="headerlink" title="JS代码是按照顺序执行的吗？"></a>JS代码是按照顺序执行的吗？</h2><blockquote><p>JS本身确实是按照顺序执行的，但是存在一些特殊场景比如变量提升和闭包</p></blockquote><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><blockquote><p>所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined</p></blockquote><p>变量提升如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">showName() <span class="hljs-comment">// 函数showName被执行</span><br><span class="hljs-built_in">console</span>.log(myname) <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> myname = <span class="hljs-string">&#x27;极客时间&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;函数showName被执行&#x27;</span>);&#125;<br></code></pre></td></tr></table></figure><p>产生变量提升的原因是</p><ul><li>js引擎把函数和变量在执行之前提升到了代码开头</li></ul><p>那这个是怎么处理的？看下面的执行流程</p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>因为变量提升所以引出一个问题，JS在浏览器执行中做了一些事情，分为编译阶段和执行阶段</p><h4 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h4><ul><li>编译后生成两部分内容：<code>执行上下文</code> 和 <code>可执行代码</code><ul><li><code>执行上下文</code>是js执行一段代码的云效环境</li><li><code>执行上下文</code>存在一个变量环境的对象，该对象中保存了变量提升的内容</li></ul></li><li>上个示例代码的分析<ul><li>第 1 行和第 2 行，由于这两行代码不是声明操作，所以 JavaScript 引擎不会做任何处理；</li><li>第 3 行，由于这行是经过 var 声明的，因此 JavaScript 引擎将在环境对象中创建一个名为 myname 的属性，并使用 undefined 对其初始化；</li><li>第 4 行，JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建一个 showName 的属性，然后将该属性值指向堆中函数的位置</li></ul></li></ul><p>编译后有了可执行的上下文环境以及执行代码进入执行阶段</p><h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h4><ul><li><p>上课示例代码的执行</p><ul><li><p>当执行到 showName 函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出“函数 showName 被执行”结果。</p></li><li><p>接下来打印“myname”信息，JavaScript 引擎继续在变量环境对象中查找该对象，由于变量环境存在 myname 变量，并且其值为 undefined，所以这时候就输出 undefined。</p></li><li><p>接下来执行第 3 行，把“极客时间”赋给 myname 变量，赋值后变量环境中的 myname 属性值改变为“极客时间”，变量环境如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">VariableEnvironment:<br>myname -&gt; <span class="hljs-string">&quot;极客时间&quot;</span>,<br>        showName -&gt;<span class="hljs-function"><span class="hljs-keyword">function</span> : </span>&#123;<span class="hljs-built_in">console</span>.log(myname)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>代码出现相同的变量以及函数怎么处理？</p><ul><li>会在编译阶段，最后拿到的变量或者函数为最终值</li></ul></li></ul><h2 id="调用栈：为什么JS会栈溢出"><a href="#调用栈：为什么JS会栈溢出" class="headerlink" title="调用栈：为什么JS会栈溢出"></a>调用栈：为什么JS会栈溢出</h2><h3 id="哪些代码为可以在编译的时候创建独立的上下文？"><a href="#哪些代码为可以在编译的时候创建独立的上下文？" class="headerlink" title="哪些代码为可以在编译的时候创建独立的上下文？"></a>哪些代码为可以在编译的时候创建独立的上下文？</h3><ul><li>首先是全局上下文，JS执行全局代码的时候会创建全局上下文，并且整个页面生命周期内只有一份</li><li>当调用一个函数会创建执行上下文，一般情况执行结束上下文也会被摧毁</li><li>使用eval函数的时候（已经弃用）</li></ul><h3 id="函数调用和栈的关系"><a href="#函数调用和栈的关系" class="headerlink" title="函数调用和栈的关系"></a>函数调用和栈的关系</h3><blockquote><p>JS函数调用会产生执行上下文，但是有时候可能一个函数里面还包有另外一个函数，所以执行上下文有可能是多个，而JS引擎就是用<code>栈</code>这种数据结构来管理<code>执行上下文的</code></p></blockquote><h4 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h4><ul><li>一种数据结构容器</li><li>特点就是<code>先进后出</code></li></ul><h3 id="什么是JS调用栈"><a href="#什么是JS调用栈" class="headerlink" title="什么是JS调用栈"></a>什么是JS调用栈</h3><ul><li>JS引擎管理<code>执行上下文</code>的栈结构</li><li>JS引擎会把<code>执行上下文</code>压入栈中，把这种管理叫做调用栈</li></ul><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><ul><li>JS引擎的调用栈是有大小的，超过一定的<code>执行上下文</code>就会报错</li><li>递归最容易因为没有边界条件导致栈溢出，所以有时候处理问题需要用setTimeout来优化，为什么使用定时器可以解决栈移除问题？ function foo() { setTimeout(foo, 0) } foo() 像setTimeout 、setInterval Promise 这样的全局函数不是js 的一部分，而是webapi 部分。 当遇到webApi 时，会将其回调函数(foo)交给web apis 处理，此时 调用栈 中foo 函数执行完毕，出栈，栈为空； 回调函数会被发送到任务队列中，等待event loop 事件循环将其捞出 重新放入到堆栈中 …. 参考：<a href="https://juejin.im/post/5d2d146bf265da1b9163c5c9#heading-15">https://juejin.im/post/5d2d146bf265da1b9163c5c9#heading-15</a></li></ul><h2 id="块级作用域以及var缺陷以及const-let出现"><a href="#块级作用域以及var缺陷以及const-let出现" class="headerlink" title="块级作用域以及var缺陷以及const let出现"></a>块级作用域以及var缺陷以及const let出现</h2><p>会出现变量提升得原因就是因为之前ES规范不支持块级作用域，因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。</p><p>块级作用域是为了解决变量提升带来得缺陷</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><blockquote><p>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期</p></blockquote><ul><li>全局作用域<ul><li>在代码中得任何地方都可访问，其生命周期伴随着页面的生命周期</li></ul></li><li>函数作用域<ul><li>函数内部得函数或者变量只能在函数内部访问，函数执行完后 内部得变量也会被销毁</li></ul></li></ul><h3 id="变量提升缺陷"><a href="#变量提升缺陷" class="headerlink" title="变量提升缺陷"></a>变量提升缺陷</h3><ul><li><p>变量易被覆盖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><br><span class="hljs-comment">/***********************没有块级作用域覆盖***************************/</span><br><br><span class="hljs-keyword">var</span> myname = <span class="hljs-string">&quot;极客时间&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(myname); <span class="hljs-comment">// undefined</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>)&#123;<br>   <span class="hljs-keyword">var</span> myname = <span class="hljs-string">&quot;极客邦&quot;</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(myname); <span class="hljs-comment">// undefined</span><br>&#125;<br>showName()<br><span class="hljs-comment">// 原因就是因为执行showName 得时候 if语句内得 myname被读取 导致出现变量提升覆盖了全局得 myname</span><br><span class="hljs-comment">/**********************块级作用域未被覆盖****************************/</span><br><br><span class="hljs-keyword">let</span> myname1 = <span class="hljs-string">&quot;极客时间&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName1</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(myname1); <span class="hljs-comment">// 极客时间</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>)&#123;<br>   <span class="hljs-keyword">let</span> myname1 = <span class="hljs-string">&quot;极客邦&quot;</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(myname1); <span class="hljs-comment">// 极客时间</span><br>&#125;<br>showName1()<br><br><span class="hljs-comment">/**************************************************/</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>变量在应该销毁得情况下未被销毁</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/***********没有块级作用域得*************/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 7未被销毁 因为 i 在foo函数作用域里存在</span><br>&#125;<br>foo()<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="如何支持块级作用域"><a href="#如何支持块级作用域" class="headerlink" title="如何支持块级作用域"></a>如何支持块级作用域</h3><ul><li><p>引入const与let</p><p>为了解决块级作用域问题</p></li><li><p>如何支持块级作用域</p><p>需要站在<code>执行上下文得角度</code>来看，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span><br>    &#123;<br>      <span class="hljs-keyword">let</span> b = <span class="hljs-number">3</span><br>      <span class="hljs-keyword">var</span> c = <span class="hljs-number">4</span><br>      <span class="hljs-keyword">let</span> d = <span class="hljs-number">5</span><br>      <span class="hljs-built_in">console</span>.log(a)<br>      <span class="hljs-built_in">console</span>.log(b)<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(b) <br>    <span class="hljs-built_in">console</span>.log(c)<br>    <span class="hljs-built_in">console</span>.log(d)<br>&#125;   <br>foo()<br></code></pre></td></tr></table></figure><ul><li>第一步编译并创建执行上下文<ul><li>函数内部var的变量，编译阶段全存放到<code>变量环境</code>中</li><li>通过let的声明的变量，在编译阶段会被存放到<code>词法环境</code></li><li>函数的作用域块内部，通过let声明的变量并没有被存放在词法环境中</li></ul></li><li>第二部执行<ul><li>执行函数在找寻变量时 是按照 先 <code>词法环境</code>再<code>变量环境</code>，<code>词法环境</code>也是自上而下查找</li><li><code>词法环境</code>内部维护了小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，会把内部的变量全部压入栈中，执行完作用域后然后从栈顶释放</li></ul></li></ul></li></ul><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>在执行块级作用域时，如果变量未被赋值直接访问，会报错 Cannot access ‘****’ before initialization</p><ul><li>原因<ul><li>在块作用域内，let声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。</li></ul></li></ul><p>如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-built_in">console</span>.log(myname25) <br>  <span class="hljs-keyword">let</span> myname25= <span class="hljs-string">&#x27;极客邦&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="作用域链和闭包-：代码中出现相同的变量，JavaScript引擎是如何选择的"><a href="#作用域链和闭包-：代码中出现相同的变量，JavaScript引擎是如何选择的" class="headerlink" title="作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的"></a>作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的</h2><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><blockquote><p>其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer</p></blockquote><ul><li>寻找变量时JS引擎首先会在<code>当前的执行上下文</code>中查找变量，先找<code>词法环境</code>再<code>变量环境</code></li><li>还没找到时就会找<code>outer</code>的外部引用变量环境，没找到继续找outer的outer一直找到全局的 <code>outer</code>，而全局的<code>outer</code>是指向<code>null</code>的，这个就是作用域链</li></ul><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><blockquote><p>词法作用域就是指作用域是由代码中函数<strong>声明的位置来决定的</strong>，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符，在编译的时候已经确定词法作用域了，和函数怎么调用没关系，词法作用域规定了 <code>outer</code>指向那里</p></blockquote><p>如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(text)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span> (<span class="hljs-params"></span>) </span>&#123;<br>&#123;<br><span class="hljs-keyword">let</span> text = <span class="hljs-number">1</span><br>         bar()<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> text = <span class="hljs-number">2</span><br>show() <span class="hljs-comment">//  打印出来是2，原因就是 bar 定义在全局 所以它的词法作用域就在全局 ，编译的时候 outer自然指向全局，而全局下的 text是2 </span><br><br></code></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>之前的概念，闭包就是返回一个对象访问 函数内部的变量 。</p><p>接下来看demo</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot;极客时间&quot;</span><br>    <span class="hljs-keyword">let</span> test1 = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">const</span> test2 = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">var</span> innerBar = &#123;<br>        getName:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(test1)<br>            <span class="hljs-keyword">return</span> myName<br>        &#125;,<br>        setName:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newName</span>)</span>&#123;<br>            myName = newName<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> innerBar<br>&#125;<br><span class="hljs-keyword">var</span> bar = foo()<br>bar.setName(<span class="hljs-string">&quot;极客邦&quot;</span>)<br>bar.getName()<br><span class="hljs-built_in">console</span>.log(bar.getName())<br></code></pre></td></tr></table></figure><p>这个当然产生了闭包，而用刚才的知识就是 foo 函数虽然被 调用完成了，但是 bar 变量引用了 返回的 innerBar 导致 ，而innerBar的 outer 是 foo 函数的 环境上下文，所以 foo函数的 test1 以及 myName 变量就无法被销毁，所以只要调用 innerBar的 方法 就会访问这个未被销毁的 环境上下文，这个无法销毁的环境上下文 就是 foo 函数产生的闭包 </p><ul><li>定义 <ul><li>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。</li><li>调用 顺序是 调用闭包 ，然后闭包里的 outer</li></ul></li></ul><h3 id="闭包回收"><a href="#闭包回收" class="headerlink" title="闭包回收"></a>闭包回收</h3><p>闭包容易造成内存泄漏，因为无法被回收，通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。避免这种现象的出现就是 把闭包 要被赋值的变量 定义为局部的 而不是全局，局部变量的函数调用完后 会直接 销毁函数，所以内部的 局部变量也会被销毁</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器工作原理与实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器中的网络</title>
    <link href="/sevenflow.blog/2021/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C/"/>
    <url>/sevenflow.blog/2021/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器中的网络"><a href="#浏览器中的网络" class="headerlink" title="浏览器中的网络"></a>浏览器中的网络</h1><h2 id="HTTP-1-HTTP性能优化"><a href="#HTTP-1-HTTP性能优化" class="headerlink" title="HTTP/1: HTTP性能优化"></a>HTTP/1: HTTP性能优化</h2><blockquote><p>浏览器与服务器的通信语言</p></blockquote><h3 id="超文本传输协议HTTP-0-9"><a href="#超文本传输协议HTTP-0-9" class="headerlink" title="超文本传输协议HTTP/0.9"></a>超文本传输协议HTTP/0.9</h3><blockquote><p>HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为超文本传输协议。</p></blockquote><h4 id="HTTP-0-9-完整请求流程"><a href="#HTTP-0-9-完整请求流程" class="headerlink" title="HTTP/0.9 完整请求流程"></a>HTTP/0.9 完整请求流程</h4><ul><li>因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。</li><li>建立好连接之后，会发送一个 GET 请求行的信息，如GET /index.html用来获取 index.html。</li><li>服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。</li><li>HTML 文档传输完成后，断开连接。</li></ul><p><img src="https://static001.geekbang.org/resource/image/db/34/db1166c68c22a45c9858e88a234f1a34.png" alt="img"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。</li><li>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</li><li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。<a href="https://segmentfault.com/q/1010000010875486/a-1020000010879359">原因</a></li></ul><h3 id="被浏览器推动的-HTTP-1-0"><a href="#被浏览器推动的-HTTP-1-0" class="headerlink" title="被浏览器推动的 HTTP/1.0"></a>被浏览器推动的 HTTP/1.0</h3><ul><li><p>原因</p><ul><li>网景新出的浏览器不仅仅支持了HTML文件还包括了JS，css，图片，音频，视频等。因此支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件。</li></ul></li><li><p>实现多种数据类型的方式</p><ul><li><p>HTTP/1.0 引入请求头与响应头，以key-value的形式保存，HTTP请求会带上请求头信息，服务器返回数据时，会先返回响应头信息</p><p><img src="https://static001.geekbang.org/resource/image/b5/7d/b52b0d1a26ff2b8607c08e5c50ae687d.png" alt="img"></p></li><li><p>浏览器需要知道服务器返回数据的类型，浏览器才能根据不同的数据类型做针对性处理</p></li><li><p>因为数据量越来越大，为了减轻传输性能，服务器会对数据进行压缩后再传输，所以浏览器需要知道服务器的压缩方法</p></li><li><p>万维网时全球范围的，所以需要提供国际化的支持，需要浏览器告诉服务器需要什么语言版本的页面</p></li><li><p>增加不同类型的文件，而每种文件编码形式又可能不一样，为了能够准确地读取文件，浏览器需要知道文件的编码类型</p><p>HTTP/1.0的请求头</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">accept: text/html <span class="hljs-comment">// 文件类型</span><br>accept-encoding: gzip, deflate, br <span class="hljs-comment">// 压缩方式</span><br>accept-Charset: ISO-<span class="hljs-number">8859</span>-<span class="hljs-number">1</span>,utf-<span class="hljs-number">8</span> <span class="hljs-comment">// 文件编码</span><br>accept-language: zh-CN,zh <span class="hljs-comment">// 优先语言是中文</span><br></code></pre></td></tr></table></figure><p>比如服务器不支持gzip，支支持br压缩，那么响应头就会带有 压缩类型，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">content-encoding: br<br>content-type: text/html; charset=UTF-<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>HTTP/0.1其他特性</p><ul><li>服务器有可能出错，需要浏览器进行错误处理，所以就引入了<code>状态码</code>，是通过响应行的方式来通知浏览器的</li><li>为了减轻服务器压力，在HTTP/1.0提供了<code>Cache缓存</code>，用来缓存已经下载过的数据</li><li>服务器需要统计客户端基础信息，在1.0请求头中还加入了<code>用户代理</code>的字段</li></ul></li></ul><h3 id="缝缝补补的HTTP-1-1"><a href="#缝缝补补的HTTP-1-1" class="headerlink" title="缝缝补补的HTTP/1.1"></a>缝缝补补的HTTP/1.1</h3><ul><li>改进持久连接<ul><li>HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。</li></ul></li><li>不成熟的HTTP管线化<ul><li>持久连接能减少TCP的建立与断开次数，但是它需要等待前面的请求返回之后，才能进行下次请求，TCP通道中某个请求因为某些原因没有即使返回，就会阻塞后面的所有请求，这个就是<code>队头阻塞</code>的问题</li><li>HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。不过因为各种原因，特们最终都放弃了管线化技术</li></ul></li><li>提供虚拟机支持<ul><li>在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。因此，HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</li></ul></li><li>对动态生成的内容提供了完美支持<ul><li>在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据</li><li>不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。</li><li>HTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</li></ul></li></ul><h2 id="HTTP-2-如何提升网络速度"><a href="#HTTP-2-如何提升网络速度" class="headerlink" title="HTTP/2 如何提升网络速度"></a>HTTP/2 如何提升网络速度</h2><h3 id="HTTP1-1的主要问题"><a href="#HTTP1-1的主要问题" class="headerlink" title="HTTP1.1的主要问题"></a>HTTP1.1的主要问题</h3><blockquote><p>带宽是指每秒最大能发送或者接收的字节数, 我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。</p></blockquote><ul><li>对带宽的利用率不理想<ul><li>第一个原因，TCP 的慢启动。</li><li>第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。</li><li>第三个原因，HTTP/1.1 队头阻塞的问题。</li></ul></li></ul><h3 id="HTTP-2的多路复用"><a href="#HTTP-2的多路复用" class="headerlink" title="HTTP/2的多路复用"></a>HTTP/2的多路复用</h3><ul><li>一个域名只使用一个TCP长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题</li><li>HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。</li><li>多路复用图解<ul><li>图中你会发现每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。</li><li>服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容，比如服务器可能早就缓存好了 index.html 和 bar.js 的响应头信息，那么当接收到请求的时候就可以立即把 index.html 和 bar.js 的响应头信息返回给浏览器，然后再将 index.html 和 bar.js 的响应体数据返回给浏览器，之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。</li><li>HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。</li></ul></li></ul><p><img src="https://static001.geekbang.org/resource/image/0a/00/0a990f86ad9c19fd7d7620b2ef7ee900.jpg" alt="img"></p><h3 id="多路复用的实现"><a href="#多路复用的实现" class="headerlink" title="多路复用的实现"></a>多路复用的实现</h3><p>图解</p><p><img src="https://static001.geekbang.org/resource/image/86/6a/86cdf01a3af7f4f755d28917e58aae6a.png" alt="img"></p><p>在TCP层又加了一层 <strong>二进制分帧层</strong>， 就实现了 HTTP 的多路复用技术。</p><ul><li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体</li><li>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。</li><li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。</li><li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</li><li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li><li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。</li></ul><p>HTTP2只改变了传输方式，其他都没有改变</p><h3 id="HTTP-2-其他特性"><a href="#HTTP-2-其他特性" class="headerlink" title="HTTP/2 其他特性"></a>HTTP/2 其他特性</h3><ul><li>设置请求优先级<ul><li>发送请求时，可以标记请求优先级，服务器接到后就会优先处理优先级高的请求</li></ul></li><li>服务器推送<ul><li>直接将数据提前推送给浏览器，用户请求HTML文件，相关的JS和css文件重要，就直接一起发给浏览器</li></ul></li><li>头部压缩<ul><li>对请求头和响应头进行了压缩</li></ul></li></ul><h2 id="HTTP-3：甩掉TCP、TLS-的包袱，构建高效网络"><a href="#HTTP-3：甩掉TCP、TLS-的包袱，构建高效网络" class="headerlink" title="HTTP/3：甩掉TCP、TLS 的包袱，构建高效网络"></a>HTTP/3：甩掉TCP、TLS 的包袱，构建高效网络</h2><h3 id="TCP存在的问题"><a href="#TCP存在的问题" class="headerlink" title="TCP存在的问题"></a>TCP存在的问题</h3><ul><li><p>TCP的队头阻塞</p><ul><li><p>因为http2还是基于TCP协议，所以还存在阻塞问题，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。</p></li><li><p>在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。下图是http2丢包传输阻塞</p><p><img src="https://static001.geekbang.org/resource/image/48/d1/4837434655a6d87f1bf5e3d899a698d1.png" alt="img"></p></li><li><p>当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。</p></li></ul></li><li><p>TCP建立连接的延时</p><ul><li><p>网络延迟又称 RTT(Round Trip Time)，我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT，如下</p><p><img src="https://static001.geekbang.org/resource/image/e9/4f/e98927e19b20349815fb8f499067cb4f.png" alt="img"></p></li><li><p>建立TCP协议需要和服务器三次握手，需要1.5个RTT，如果有HTTPS，TLS协议还需要一个握手过程，因为TSL协议不同需要握手时间也不同大概1<del>2个RTT，在传输数据之前，需要花掉3</del>4个RTT，如果服务器距离进 一个 RTT可能在10ms之内，如果远那么就在100ms以上了，所以整个过程可能在30-40ms or 300-400ms，用户可以明显感觉到卡顿了</p></li></ul></li><li><p>TCP协议僵化</p><p>我们知道TCP协议存在问题，那么能不能修改呢 答案是<strong>非常困难</strong></p><ul><li>中间设备的僵化<ul><li>互联网是一个网状结构，为了能够保障互联网的正常工作，我们需要在互联网的各处搭建各种设备，这些设备就被称为中间设备。</li><li>这些设备包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。</li><li>如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。</li></ul></li><li>操作系统僵化<ul><li>TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的</li></ul></li></ul></li></ul><h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><p>  因为TCP本身局限性，以及设备和操作系统的僵化，HTTP/3 选择了一个折中的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为<strong>QUIC 协议</strong>，如下</p><p><img src="https://static001.geekbang.org/resource/image/0b/c6/0bae470bb49747b9a59f9f4bb496a9c6.png" alt="img"></p><ul><li>QUIC协议的功能<ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能</li><li>集成了 TLS 加密功能，目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</li><li>实现了 HTTP/2 中的多路复用功能</li><li>实现了快速握手功能</li></ul></li></ul><h3 id="HTTP-3的挑战"><a href="#HTTP-3的挑战" class="headerlink" title="HTTP/3的挑战"></a>HTTP/3的挑战</h3><ul><li>从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。</li><li>部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</li><li>中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。</li></ul><p><a href="https://mp.weixin.qq.com/s/iF0wbV5o7HVjGG_Cb-RcOg">HTTP/3原理与实践</a></p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器工作原理与实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器安全</title>
    <link href="/sevenflow.blog/2021/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    <url>/sevenflow.blog/2021/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1><ul><li>web页面安全</li><li>浏览器网络安全</li><li>浏览器系统安全</li></ul><h2 id="同源策略：为什么XMLHttpRequest不能跨域请求资源？"><a href="#同源策略：为什么XMLHttpRequest不能跨域请求资源？" class="headerlink" title="同源策略：为什么XMLHttpRequest不能跨域请求资源？"></a>同源策略：为什么XMLHttpRequest不能跨域请求资源？</h2><ul><li>浏览器页面中没有安全策略会怎么样？<ul><li>修改银行站点的 DOM、CSSOM 等信息；</li><li>在银行站点内部插入 JavaScript 脚本</li><li>读取银行站点的 Cookie、IndexDB 等数据；</li><li>甚至还可以将这些信息上传至自己的服务器，这样就可以在你不知情的情况下伪造一些转账请求等信息。</li></ul></li></ul><p>在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全。</p><h3 id="页面中最基础，最核心的安全策略：同源策略"><a href="#页面中最基础，最核心的安全策略：同源策略" class="headerlink" title="页面中最基础，最核心的安全策略：同源策略"></a>页面中最基础，最核心的安全策略：同源策略</h3><ul><li>什么是同源策略？<ul><li>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。</li><li>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。</li><li>具体来讲，同源策略主要表现在 DOM、Web 数据和网络这三个层面。</li></ul></li><li>DOM层面<ul><li>同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</li></ul></li><li>数据层面<ul><li>同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。</li></ul></li><li>网络层面<ul><li>同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</li></ul></li></ul><h3 id="安全以及便利性权衡"><a href="#安全以及便利性权衡" class="headerlink" title="安全以及便利性权衡"></a>安全以及便利性权衡</h3><p>让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得 Web 项目难以开发和使用，所以浏览器对同源策略做出了让步</p><ul><li>页面中可以嵌入第三方资源<ul><li>如iframe，或者图片 css资源 js资源</li><li>但是这样可能会导致有人恶意使用注入恶意代码，这就是xss攻击<ul><li>为了解决xss攻击，浏览器引入了内容安全策略称为CSP</li><li><strong>CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码</strong></li><li>配置内容安全策略涉及到添加 Content-Security-Policy HTTP头部到一个页面，并配置相应的值，以控制用户代理（浏览器等）可以为该页面获取哪些资源。比如一个可以上传文件和显示图片页面，应该允许图片来自任何地方，但限制表单的action属性只可以赋值为指定的端点。一个经过恰当设计的内容安全策略应该可以有效的保护页面免受跨站脚本攻击 </li></ul></li></ul></li><li>跨域资源共享和跨文档消息机制<ul><li>跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</li><li>在实际应用中需要不同源DOM之前通信，所以加入了<strong>跨文档消息机制</strong>window.postMessage</li></ul></li></ul><h2 id="跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？"><a href="#跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？" class="headerlink" title="跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？"></a>跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？</h2><h3 id="什么是xss攻击？"><a href="#什么是xss攻击？" class="headerlink" title="什么是xss攻击？"></a>什么是xss攻击？</h3><blockquote><p>是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</p></blockquote><p>恶意脚本能做哪些事情？</p><ul><li>可以窃取 Cookie 信息<ul><li>恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。</li></ul></li><li>可以监听用户行为。<ul><li>恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。</li></ul></li><li>可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。</li><li>还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。</li></ul><h3 id="恶意脚本怎么注入？"><a href="#恶意脚本怎么注入？" class="headerlink" title="恶意脚本怎么注入？"></a>恶意脚本怎么注入？</h3><p>通常情况下，主要有存<strong>储型 XSS 攻击</strong>、<strong>反射型 XSS 攻击</strong>和<strong>基于 DOM 的 XSS</strong> 攻击三种方式来注入恶意脚本。</p><ul><li>存储型XSS攻击<ul><li>首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；</li><li>然后用户向网站请求包含了恶意 JavaScript 脚本的页面；</li><li>当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。</li></ul></li><li>反射型 XSS 攻击<ul><li>用户将一段含有恶意代码的请求提交给 Web 服务器</li><li>Web 服务器接收到请求时，又将恶意代码反射给了浏览器端</li><li>比如 在url加入参数 页面会显示参数，如果直接加入script脚本，页面就会执行</li><li>Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。</li></ul></li><li>基于 DOM 的 XSS 攻击<ul><li>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的</li><li>有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。</li></ul></li></ul><h3 id="如何阻止-XSS-攻击"><a href="#如何阻止-XSS-攻击" class="headerlink" title="如何阻止 XSS 攻击"></a>如何阻止 XSS 攻击</h3><p>存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理的，因此可以认为这两种类型的漏洞是服务端的安全漏洞，而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于前端的安全漏洞</p><ul><li>服务器对输入脚本进行过滤或转码<ul><li>不管是反射型还是存储型 XSS 攻击，我们都可以在服务器端将一些关键的字符进行转码</li></ul></li><li>充分利用 CSP<ul><li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；</li><li>禁止向第三方域提交数据，这样用户数据也不会外泄；</li><li>禁止执行内联脚本和未授权的脚本；</li><li>还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题</li></ul></li><li>使用 HttpOnly 属性<ul><li>很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。</li><li>，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。</li></ul></li></ul><h2 id="CSRF攻击：陌生链接不要随便点"><a href="#CSRF攻击：陌生链接不要随便点" class="headerlink" title="CSRF攻击：陌生链接不要随便点"></a>CSRF攻击：陌生链接不要随便点</h2><h3 id="什么是-CSRF-攻击"><a href="#什么是-CSRF-攻击" class="headerlink" title="什么是 CSRF 攻击"></a>什么是 CSRF 攻击</h3><blockquote><p>英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求,CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。</p></blockquote><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://static001.geekbang.org/resource/image/3d/6b/3d7f097b1d6a8f93a960a12892f1556b.png" alt="img"></p><ul><li>首先 David 发起登录 Gmail 邮箱请求，然后 Gmail 服务器返回一些登录状态给 David 的浏览器，这些信息包括了 Cookie、Session 等，这样在 David 的浏览器中，Gmail 邮箱就处于登录状态了。</li><li>接着黑客通过各种手段引诱 David 去打开他的链接，比如 hacker.com，然后在 hacker.com 页面中，黑客编写好了一个邮件过滤器，并通过 Gmail 提供的 HTTP 设置接口设置好了新的邮件过滤功能，该过滤器会将 David 所有的邮件都转发到黑客的邮箱中。</li><li>最后的事情就很简单了，因为有了 David 的邮件内容，所以黑客就可以去域名服务商那边重置 David 域名账户的密码，重置好密码之后，就可以将其转出到黑客的账户了。</li></ul><p>通常当用户打开了黑客的页面后，黑客有三种方式去实施 CSRF 攻击。</p><ul><li><p>自动发起 Get 请求</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>黑客的站点：CSRF攻击演示<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;hacker-form&#x27;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;https://time.geekbang.org/sendcoin&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">POST</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hacker&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"> <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;hacker-form&#x27;</span>).submit(); </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>自动发起POST请求</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>黑客的站点：CSRF攻击演示<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;hacker-form&#x27;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;https://time.geekbang.org/sendcoin&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">POST</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hacker&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"> <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;hacker-form&#x27;</span>).submit(); </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>引诱用户点击链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">width</span>=<span class="hljs-string">150</span> <span class="hljs-attr">src</span>=<span class="hljs-string">http://images.xuejuzi.cn/1612/1_161230185104_1.jpg</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://time.geekbang.org/sendcoin?user=hacker&amp;number=100&quot;</span> <span class="hljs-attr">taget</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span><br>    点击下载美女照片<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</p><h3 id="如何防止CSRF攻击"><a href="#如何防止CSRF攻击" class="headerlink" title="如何防止CSRF攻击"></a>如何防止CSRF攻击</h3><p>先说发起CSRF攻击的三个必要条件</p><ul><li>目标站点一定要有CSRF漏洞</li><li>用户要登陆过目标站点，并且在浏览器上保持登录状态</li><li>需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛</li></ul><p>与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。</p><p>防止遭受CSRF攻击：</p><ul><li><p>充分利用好 Cookie 的 SameSite 属性</p><ul><li><p>Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据，因此要阻止 CSRF 攻击，我们首先就要考虑在 Cookie 上来做文章。</p><ul><li>如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器；</li><li>如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。</li></ul></li><li><p>Cookie 中的 SameSite 属性正是为了解决这个问题的</p><ul><li><pre><code class="js">set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none</code></pre></li><li><p>SameSite 选项通常有 Strict、Lax 和 None 三个值</p><ul><li>Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。</li><li>Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。</li><li>而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。</li></ul></li></ul></li></ul></li><li><p>验证请求的来源站点，在服务器端验证请求来源的站点</p><ul><li>Referer：Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址</li><li>Origin ：Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别</li><li>服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。</li></ul></li><li><p>CSRF Token</p><ul><li>在浏览器向服务器发起请求时，服务器生成一个 CSRF Token</li><li>在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法，。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器工作原理与实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器中的页面循环系统</title>
    <link href="/sevenflow.blog/2021/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F/"/>
    <url>/sevenflow.blog/2021/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器中的页面循环系统"><a href="#浏览器中的页面循环系统" class="headerlink" title="浏览器中的页面循环系统"></a>浏览器中的页面循环系统</h1><h2 id="消息队列和事件循环：页面是怎么“活”起来的？"><a href="#消息队列和事件循环：页面是怎么“活”起来的？" class="headerlink" title="消息队列和事件循环：页面是怎么“活”起来的？"></a>消息队列和事件循环：页面是怎么“活”起来的？</h2><h3 id="使用单线程处理安排好的任务"><a href="#使用单线程处理安排好的任务" class="headerlink" title="使用单线程处理安排好的任务"></a>使用单线程处理安排好的任务</h3><ul><li>缺点<ul><li>无法接受新的任务</li></ul></li><li>解决方案<ul><li>利用事件循环来收集新的任务</li><li>条件<ul><li>引入循环机制，for循环语句</li><li>引入事件</li></ul></li></ul></li></ul><p>具体如下</p><p><img src="https://static001.geekbang.org/resource/image/9e/e3/9e0f595324fbd5b7cd1c1ae1140f7de3.png" alt="img"></p><h3 id="处理其他线程发送过来的任务（多线程处理）"><a href="#处理其他线程发送过来的任务（多线程处理）" class="headerlink" title="处理其他线程发送过来的任务（多线程处理）"></a>处理其他线程发送过来的任务（多线程处理）</h3><p>上面只适用单线程，如果是多线程 如下</p><p><img src="https://static001.geekbang.org/resource/image/2e/05/2eb6a8ecb7cb528da4663573d74eb305.png" alt="img"></p><p>处理这种模式 就需要 用到<strong>消息队列</strong></p><ul><li>解决方案<ul><li>利用消息队列，是一种数据结构，可以存放要执行的任务，符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。</li></ul></li><li>改造步骤<ul><li>添加一个消息队列</li><li>IO 线程中产生的新任务添加进消息队列尾部</li><li>渲染主线程会循环地从消息队列头部中读取任务，执行任务</li></ul></li></ul><p>如下</p><p><img src="https://static001.geekbang.org/resource/image/2a/ab/2ac6bc0361cb4690c5cc83d8abad22ab.png" alt="img"></p><h3 id="处理多进程发送过的任务"><a href="#处理多进程发送过的任务" class="headerlink" title="处理多进程发送过的任务"></a>处理多进程发送过的任务</h3><p>消息队列可以处理多线程通信，但是浏览器还需要多进程任务，其实和多线程一样，<strong>渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息</strong></p><p><img src="https://static001.geekbang.org/resource/image/e2/c6/e2582e980632fd2df5043f81a11461c6.png" alt="img"></p><h3 id="消息队列中的任务类型"><a href="#消息队列中的任务类型" class="headerlink" title="消息队列中的任务类型"></a>消息队列中的任务类型</h3><ul><li>内部消息类型<ul><li>输入事件（鼠标滚动点击移动）</li><li>微任务</li><li>文件读写</li><li>websocket</li><li>JS的定时器</li><li>…</li></ul></li><li>页面相关的事件<ul><li>JS执行</li><li>解析DOM</li><li>样式计算</li><li>布局计算</li><li>css动画</li></ul></li></ul><p>以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。</p><h3 id="安全退出线程"><a href="#安全退出线程" class="headerlink" title="安全退出线程"></a>安全退出线程</h3><p>确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时</p><h3 id="页面使用单线程的缺点"><a href="#页面使用单线程的缺点" class="headerlink" title="页面使用单线程的缺点"></a>页面使用单线程的缺点</h3><p>页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。</p><ul><li>如何处理高优先级的任务<ul><li>消息队列中每个任务都是宏任务，在执行宏任务时，有例如DOM渲染这样的<strong>微任务</strong>执行那么就添加到当前宏任务的微任务队列，当宏任务的主任务列表执行完后，就会开始执行<strong>微任务</strong>列表</li></ul></li><li>如何处理一个任务时长过长的问题<ul><li>所有任务是单线程执行，每次只能执行一个任务，任务时长过长就会导致后面的任务长时间等待，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。</li></ul></li></ul><h2 id="WebAPI-setTimeout是如何实现的？"><a href="#WebAPI-setTimeout是如何实现的？" class="headerlink" title="WebAPI:setTimeout是如何实现的？"></a>WebAPI:setTimeout是如何实现的？</h2><ul><li>新建了一个 <strong>延迟任务</strong>消息队列，所有定时器都会在这个队列中</li><li>每当一个消息队列中的宏任务执行完成，就会执行 <strong>延迟任务</strong>消息队列中的任务（所以有时延时函数执行等待时长会比定时长）</li><li>clearTimeout 实现就是传入 setTimeout 返回的 number，通过这个查找到相关的事件 id 然后在 延时队列中删掉即可</li></ul><h3 id="使用setTimeout-的注意事项"><a href="#使用setTimeout-的注意事项" class="headerlink" title="使用setTimeout 的注意事项"></a>使用setTimeout 的注意事项</h3><ul><li><p>当前任务执行事件过久，会影响定时器任务的执行</p><ul><li><p>如下</p></li><li><pre><code class="js">function bar() &#123;    console.log(&#39;bar&#39;)&#125;function foo() &#123;    setTimeout(bar, 0);    for (let i = 0; i &lt; 5000; i++) &#123;        let i = 5+8+8+8        console.log(i)    &#125;&#125;foo()// 虽然延时 0 秒，但是需要先把 for 循环走完 才能走 延时函数，所以真实延时就是for循环走完后的时间<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 如果 setTimeout 存在嵌套调用，那么浏览器系统会设置最短时间间隔为 4 毫秒<br><br><span class="hljs-bullet">-</span> 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒<br><br><span class="hljs-bullet">  -</span> 如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。<br><br><span class="hljs-bullet">-</span> 延时执行时间有最大值<br><br><span class="hljs-bullet">  -</span> Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。<br><br><span class="hljs-bullet">-</span> 使用 setTimeout 设置的回调函数中的 this 不符合直觉<br><br><span class="hljs-bullet">  -</span> 如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象，如果是严格模式，会被设置为 undefined。<br><br><span class="hljs-section">## WebAPI:XMLHttpRequest是怎么实现的？</span><br><br>先介绍下<span class="hljs-strong">**同步回调**</span>和<span class="hljs-strong">**异步回调**</span>这两个概念<br><br><span class="hljs-section">### 回调函数 VS 系统调用栈</span><br><br><span class="hljs-quote">&gt; 将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。</span><br><br><span class="hljs-bullet">-</span> 同步回调<br><br>  <span class="hljs-code">```js</span><br><span class="hljs-code">  </span><br><span class="hljs-code">  let callback = function()&#123;</span><br><span class="hljs-code">      console.log(&#x27;i am do homework&#x27;)</span><br><span class="hljs-code">  &#125;</span><br><span class="hljs-code">  function doWork(cb) &#123;</span><br><span class="hljs-code">      console.log(&#x27;start do work&#x27;)</span><br><span class="hljs-code">      cb()</span><br><span class="hljs-code">      console.log(&#x27;end do work&#x27;)</span><br><span class="hljs-code">  &#125;</span><br><span class="hljs-code">  doWork(callback)</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p>回调函数 callback 是在主函数 doWork 返回之前执行的，我们把这个回调过程称为同步回调</p></li><li><p>异步回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">let</span> callback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i am do homework&#x27;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doWork</span>(<span class="hljs-params">cb</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;start do work&#x27;</span>)<br>    <span class="hljs-built_in">setTimeout</span>(cb,<span class="hljs-number">1000</span>)   <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;end do work&#x27;</span>)<br>&#125;<br>doWork(callback)<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用了 setTimeout 函数让 callback 在 doWork 函数执行结束后，又延时了 1 秒再执行，这次 callback 并没有在主函数 doWork 内部被调用，我们把这种回调函数在主函数外部执行的过程称为<strong>异步回调</strong></p><p>当循环系统在执行一个任务的时候，都要为这个任务维护一个系统调用栈。这个系统调用栈类似于 JavaScript 的调用栈，只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的</p></li></ul><p>每个任务在执行过程中都有自己的调用栈，那么同步回调就是在当前主函数的上下文中执行回调函数，这个没有太多可讲的。</p><p>异步回调是指回调函数在主函数之外执行，一般有两种方式：</p><ul><li>第一种是把异步函数做成一个任务，添加到信息队列尾部（包含正常队列和延时队列）</li><li>第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了。</li></ul><h3 id="XMLHttpRequest-运作机制"><a href="#XMLHttpRequest-运作机制" class="headerlink" title="XMLHttpRequest 运作机制"></a>XMLHttpRequest 运作机制</h3><p><img src="https://static001.geekbang.org/resource/image/29/c6/2914a052f4f249a52077692a22ee5cc6.png" alt="img"></p><ul><li><p>创建 XMLHttpRequest 对象。</p></li><li><p>为 xhr 对象注册回调函数</p><ul><li>主要有下面几种<ul><li>ontimeout，用来监控超时请求，如果后台请求超时了，该函数会被调用；</li><li>onerror，用来监控出错信息，如果后台请求出错了，该函数会被调用；</li><li>onreadystatechange，用来监控后台请求过程中的状态，比如可以监控到 HTTP 头加载完成的消息、HTTP 响应体消息以及数据加载完成的消息等。</li></ul></li></ul></li><li><p>配置基础的请求信息</p></li><li><p>发起请求</p><p>​    渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC （进程间通信）来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数</p></li></ul><h3 id="XMLHttpRequest-使用过程中的“坑”"><a href="#XMLHttpRequest-使用过程中的“坑”" class="headerlink" title="XMLHttpRequest 使用过程中的“坑”"></a>XMLHttpRequest 使用过程中的“坑”</h3><ul><li><p>跨域问题</p></li><li><p>HTTPS 混合内容的问题</p><p>HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。</p></li></ul><h2 id="宏任务和微任务：不是所有任务都是一个待遇"><a href="#宏任务和微任务：不是所有任务都是一个待遇" class="headerlink" title="宏任务和微任务：不是所有任务都是一个待遇"></a>宏任务和微任务：不是所有任务都是一个待遇</h2><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><ul><li>渲染事件（如解析 DOM、计算布局、绘制）；</li><li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）；</li><li>JavaScript 脚本执行事件；</li><li>网络请求完成、文件读写完成事件。</li></ul><blockquote><p>为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为<strong>宏任务</strong>。</p></blockquote><ul><li>先从多个消息队列中选出一个最老的任务这个任务称为 oldestTask；</li><li>然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；</li><li>当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；</li><li>最后统计执行完成的时长等信息。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的</li></ul><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><blockquote><p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前，当这个宏任务的主函数执行结束后开始执行。</p></blockquote><p>所以异步有两种方式：</p><ol><li>第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。</li><li>第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。</li></ol><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul><li>JS执行脚本，V8创建一个全局执行上下文，在创建上下文同时也会在内部创建一个微任务队列。</li><li>执行主函数</li><li>然后执行微任务列表</li><li>微任务列表如果有宏任务，那么给任务队列增加任务</li><li>如果有微任务，给当前执行的微任务队列增加微任务</li><li>WHATWG （超文本应用技术工作组）把执行微任务的时间点称为检查点</li></ul><h4 id="如何产生微任务"><a href="#如何产生微任务" class="headerlink" title="如何产生微任务"></a>如何产生微任务</h4><ul><li>使用 MutationObserver 监控某个 DOM 节点，用JS修改这个节点</li><li>使用Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。</li></ul><h4 id="一点题外话，DOM监听的演变"><a href="#一点题外话，DOM监听的演变" class="headerlink" title="一点题外话，DOM监听的演变"></a>一点题外话，DOM监听的演变</h4><ul><li>JS改变DOM需要通知浏览器做出渲染改变，之前是 Mutation Event 回调方式，只要DOM改变立马做出改变，DOM频繁改变导致 性能卡顿</li><li>后来换为了 MutationObserver，为异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，使用数据结构来记录这期间所有的DOM变化</li><li>渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。</li></ul><h2 id="使用Promise，告别回调函数"><a href="#使用Promise，告别回调函数" class="headerlink" title="使用Promise，告别回调函数"></a>使用Promise，告别回调函数</h2><h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><ul><li>异步编程问题：代码逻辑不连续<ul><li>解决方案，利用回调函数</li></ul></li><li>封装异步代码，让处理流程变得线性<ul><li>会导致无限的回调地狱</li><li>会导致任务的不确定性，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。</li></ul></li></ul><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><ul><li>消灭嵌套</li><li>合并多个任务的错误处理</li></ul><p>Promise 实现了这两种</p><h3 id="Promise与微任务"><a href="#Promise与微任务" class="headerlink" title="Promise与微任务"></a>Promise与微任务</h3><h2 id="async-await：使用同步的方式去写异步代码"><a href="#async-await：使用同步的方式去写异步代码" class="headerlink" title="async/await：使用同步的方式去写异步代码"></a>async/await：使用同步的方式去写异步代码</h2><h3 id="生成器VS协程"><a href="#生成器VS协程" class="headerlink" title="生成器VS协程"></a>生成器VS协程</h3><blockquote><p>生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genDemo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;开始执行第一段&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;generator 2&#x27;</span><br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;开始执行第二段&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;generator 2&#x27;</span><br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;开始执行第三段&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;generator 2&#x27;</span><br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;执行结束&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;generator 2&#x27;</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;main 0&#x27;</span>)<br><span class="hljs-keyword">let</span> gen = genDemo()<br><span class="hljs-built_in">console</span>.log(gen.next().value)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;main 1&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(gen.next().value)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;main 2&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(gen.next().value)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;main 3&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(gen.next().value)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;main 4&#x27;</span>)<br></code></pre></td></tr></table></figure><p>要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念</p><blockquote><p>协程是一种比线程更加轻量级的存在,你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程,如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。</p></blockquote><p>进程包含多个线程，线程包含多个协程</p><blockquote><p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p></blockquote><p>上面代码可分析为</p><p><img src="https://static001.geekbang.org/resource/image/5e/37/5ef98bd693bcd5645e83418b0856e437.png" alt="img"></p><p>父协程有自己的调用栈，gen 协程时也有自己的调用栈，当 gen 协程通过 yield 把控制权交给父协程时，V8 是如何切换到父协程的调用栈？当父协程通过 gen.next 恢复 gen 协程时，又是如何切换 gen 协程的调用栈？</p><ul><li>gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的</li><li>当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息</li></ul><p>为了直观理解父协程和 gen 协程是如何切换调用栈的，你可以参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/92/40/925f4a9a1c85374352ee93c5e3c41440.png" alt="img"></p><blockquote><p>生成器就是协程的一种实现方式</p></blockquote><p>所以我理解 协程是一个 模式，可以有任何实现的方式</p><h3 id="async与await"><a href="#async与await" class="headerlink" title="async与await"></a>async与await</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-number">100</span><br>    <span class="hljs-built_in">console</span>.log(a)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span>)<br>foo()<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>分析一下上面的执行流程，如下</p><p><img src="https://static001.geekbang.org/resource/image/8d/94/8dcd8cfa77d43d1fb928d8b001229b94.png" alt="img"></p><p>重点在于 <code>await 100</code>这行</p><ul><li><p>执行 打印0</p></li><li><p>执行foo函数，创建调用栈，</p></li><li><p>执行打印1</p></li><li><p>执行 await 然后创建一个 promise对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">let</span> promise_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve,reject)&#123;<br>  resolve(<span class="hljs-number">100</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>在这个 promise_ 对象创建的过程中，我们可以看到在 executor 函数中调用了 resolve 函数，JavaScript 引擎会将该任务提交给微任务队列</p><p>然后 JavaScript 引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将 promise_ 对象返回给父协程。</p><p>主线程的控制权已经交给父协程了，这时候父协程要做的一件事是调用 promise_.then 来监控 promise 状态的改变。</p></li><li><p>打印3</p></li><li><p>检查微任务列表 执行 a 和 2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><br>promise_.then(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>   <span class="hljs-comment">//回调函数被激活后</span><br>  <span class="hljs-comment">//将主线程控制权交给foo协程，并将vaule值传给协程</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>该回调函数被激活以后，会将主线程的控制权交给 foo 函数的协程，并同时将 value 值传给该协程。</p><p>foo 协程激活之后，会把刚才的 value 值赋给了变量 a，然后 foo 协程继续执行后续语句，执行完成之后，将控制权归还给父协程。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器工作原理与实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8工作原理</title>
    <link href="/sevenflow.blog/2021/07/25/V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/sevenflow.blog/2021/07/25/V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="V8工作原理"><a href="#V8工作原理" class="headerlink" title="V8工作原理"></a>V8工作原理</h1><h2 id="栈空间和堆空间：数据是如何存储的？"><a href="#栈空间和堆空间：数据是如何存储的？" class="headerlink" title="栈空间和堆空间：数据是如何存储的？"></a>栈空间和堆空间：数据是如何存储的？</h2><blockquote><p>主要是为了搞清楚JS的内存机制</p></blockquote><h3 id="让人疑惑的浅拷贝和深拷贝现象"><a href="#让人疑惑的浅拷贝和深拷贝现象" class="headerlink" title="让人疑惑的浅拷贝和深拷贝现象"></a>让人疑惑的浅拷贝和深拷贝现象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-comment">// 深拷贝</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> b = a<br>    a = <span class="hljs-number">2</span><br>    <span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// 2</span><br>    <span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// 1</span><br>&#125;<br>foo()<br><br>...<br><br><span class="hljs-comment">// 浅拷贝</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> a = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;极客时间&quot;</span>&#125;<br>    <span class="hljs-keyword">var</span> b = a<br>    a.name = <span class="hljs-string">&quot;极客邦&quot;</span> <br>    <span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// name  = &quot;极客邦&quot; </span><br>    <span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// name  = &quot;极客邦&quot; </span><br>&#125;<br>foo()<br><br></code></pre></td></tr></table></figure><p>要解答这个现象需要弄清楚JS是什么类型语言，还需要搞清楚js的数据类型，以及数据类型的存储，而这个现象就是由数据类型存储引起的</p><h3 id="语言类型分类"><a href="#语言类型分类" class="headerlink" title="语言类型分类"></a>语言类型分类</h3><ul><li><p>在使用之前就需要确认其变量数据类型的称为静态语言。相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言。</p></li><li><p>支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。</p></li></ul><p>JS是 动态的弱类型，数据类型分为 原始类型 和引用类型</p><h3 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h3><p>js运行过程中的存储方式</p><ul><li><p>代码空间，主要是存储执行代码，后面做介绍</p></li><li><p>栈空间，调用栈用来存储执行上下文的</p><ul><li><p>为什么引起浅拷贝，因为引用对象的 数据存在堆中，调用栈或者说执行上下文只存储乐对象的地址，所以浅拷贝只是复制了地址</p></li><li><p>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。</p></li></ul></li><li><p>堆空间</p><ul><li>堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。</li></ul></li></ul><p>不能所有数据都放入<code>栈</code>中，因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。</p><p>比如一个函数执行完了 这个函数所占用的栈空间的环境上下文会立马被回收。</p><h3 id="再谈闭包"><a href="#再谈闭包" class="headerlink" title="再谈闭包"></a>再谈闭包</h3><p>因为正常函数执行完后 会被回收上下文，而闭包却还存在 可用变量, 所以闭包情况下会导致 基础类型的变量也在堆空间中</p><p>代码分析</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><br>    <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot;极客时间&quot;</span><br>    <span class="hljs-keyword">let</span> test1 = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">const</span> test2 = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">var</span> innerBar = &#123; <br>        setName:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newName</span>)</span>&#123;<br>            myName = newName<br>        &#125;,<br>        getName:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(test1)<br>            <span class="hljs-keyword">return</span> myName<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> innerBar<br>&#125;<br><span class="hljs-keyword">var</span> bar = foo()<br>bar.setName(<span class="hljs-string">&quot;极客邦&quot;</span>)<br>bar.getName()<br><span class="hljs-built_in">console</span>.log(bar.getName())<br><br></code></pre></td></tr></table></figure><ul><li><p>当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。</p></li><li><p>在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。</p></li><li><p>接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。</p></li><li><p>这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。</p></li><li><p>由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。</p></li></ul><blockquote><p>产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。</p></blockquote><h2 id="垃圾回收：垃圾数据是如何自动回收的？"><a href="#垃圾回收：垃圾数据是如何自动回收的？" class="headerlink" title="垃圾回收：垃圾数据是如何自动回收的？"></a>垃圾回收：垃圾数据是如何自动回收的？</h2><blockquote><p>通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。C/C++都是手动回收，何时2分配内存，何时销毁内存由代码控制，当调用一个内存却没有释放这个内存，就会内存泄漏，另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的</p></blockquote><h3 id="调用栈中的数据是如何回收的"><a href="#调用栈中的数据是如何回收的" class="headerlink" title="调用栈中的数据是如何回收的"></a>调用栈中的数据是如何回收的</h3><p>分析代码来看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> b = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;极客邦&quot;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-keyword">var</span> c = <span class="hljs-number">2</span><br>      <span class="hljs-keyword">var</span> d = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;极客时间&quot;</span>&#125;<br>    &#125;<br>    showName()<br>&#125;<br>foo()<br></code></pre></td></tr></table></figure><p>当执行foo时，调用栈和堆空间如下</p><p><img src="https://static001.geekbang.org/resource/image/d8/b0/d807ca19c2c8853ef5a38dca0fb79ab0.jpg" alt="img"></p><blockquote><p>JS引擎执行JS时会有一个记录当前执行状态的<code>指针称为ESP</code></p></blockquote><ul><li>当执行完showName函数，JS会把<code>ESP</code>下移到foo函数的执行上下文，这个下移操作就是销毁showName函数执行上下文的过程</li><li>下移后并不会销毁之前的栈空间，执行完后showName是无效空间，当有新的执行上下文会直接覆盖这块内存</li></ul><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。</p><h3 id="堆数据回收"><a href="#堆数据回收" class="headerlink" title="堆数据回收"></a>堆数据回收</h3><p>栈空间中环境上下文被回收了，但是引用对象存储在堆空间，还没有被回收，而堆空间的垃圾回收就需要JS中的垃圾回收器了，学习JS的垃圾回收期，先需要学习两个概念</p><h4 id="代际假说"><a href="#代际假说" class="headerlink" title="代际假说"></a>代际假说</h4><ul><li><p>特点</p><ul><li><p>大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</p></li><li><p>不死的对象活得更久</p><p>这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。</p></li></ul></li></ul><p>通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。</p><h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><ul><li>V8会把堆分为两个区域，而且分别由把不同的垃圾回收器<ul><li>老生代<ul><li>主垃圾回收器负责</li><li>存放生存时间久的对象</li></ul></li><li>新生代<ul><li>副垃圾回收器负责</li><li>存放生存时间短的对象</li></ul></li></ul></li></ul><h4 id="垃圾回收器流程"><a href="#垃圾回收器流程" class="headerlink" title="垃圾回收器流程"></a>垃圾回收器流程</h4><ul><li><p>垃圾回收器的执行流程，不管什么类型的垃圾回收器流程是一致的</p><ul><li>标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</li><li>回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</li><li>做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</li></ul></li><li><p>副垃圾回收器</p><ul><li><p>垃圾回收比较频繁，因为空间不大，所以只要空间满了就要回收</p></li><li><p>新生代中用 Scavenge 算法来处理</p><p><img src="https://static001.geekbang.org/resource/image/4f/af/4f9310c7da631fa5a57f871099bfbeaf.png" alt="img"></p></li></ul></li></ul><ul><li><p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p></li><li><p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p></li><li><p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</p><p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以<code>为了执行效率，一般新生区的空间会被设置得比较小。</code></p></li><li><p>对象晋升策略</p><ul><li>新生区的空间不大，所以很容易被存活的对象装满整个区域,所以经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</li></ul></li><li><p>主垃圾回收器</p><p>两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p><p>由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。</p><ul><li>标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。<img src="https://static001.geekbang.org/resource/image/6c/69/6c8361d3e52c1c37a06699ed94652e69.png" alt="img"></li><li>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：<img src="https://static001.geekbang.org/resource/image/d0/85/d015db8ad0df7f0ccb1bdb8e31f96e85.png" alt="img">这样会导致大量不连续的内存碎片，从而导致大对象无法分配到足够的连续内存，这个过程是<code>标记-清除</code>算法</li><li>为了解决清除算法问题，产生了另外一个算法<code>标记-整理</code>，只有清除过程不同，是把标记存活的对象统一放到一个连续的内存区，然后清除其他不存活的连续内存区</li></ul></li></ul><h4 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h4><blockquote><p>由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</p></blockquote><ul><li>所带来的问题<ul><li>新生代垃圾回收还好，比较小全停顿时间很短，但是旧生代内存比较大，会导致停顿时间很长，比如一个动画正在执行结果垃圾回收导致全停顿了，那么动画就暂停了</li></ul></li><li>解决问题<ul><li>V8用了<code>增量标记</code>算法解决这个问题，其实就是将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成</li><li>这样垃圾回收分成了很多个小任务，就不会感受到页面卡顿了</li></ul></li></ul><h2 id="V8如何执行一段JS代码？"><a href="#V8如何执行一段JS代码？" class="headerlink" title="V8如何执行一段JS代码？"></a>V8如何执行一段JS代码？</h2><blockquote><p>要深入理解 V8 的工作原理，你需要搞清楚一些概念和原理，比如接下来我们要详细讲解的<code>编译器（Compiler）</code>、<code>解释器（Interpreter）</code>、<code>抽象语法树（AST）</code>、<code>字节码（Bytecode）</code>、<code>即时编译器（JIT）</code>等概念，都是你需要重点关注的。</p></blockquote><h3 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h3><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><ul><li>机器不能直接理解我们缩写的代码，所以执行代码之前需要编译或者解释然后<code>翻译</code>成机器能读懂的机器语言</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>编译器<ul><li>给编译型语言用的，如c/c++，GO等</li><li>编译之后会直接<code>保留</code>机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次<code>重新编译</code>了</li></ul></li><li>解释器<ul><li>给解释型语言用的，如python和js</li><li>在每次运行时都需要通过解释器对程序进行动态解释和执行</li></ul></li></ul><h4 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h4><p><img src="https://static001.geekbang.org/resource/image/4e/81/4e196603ecb78188e99e963e251b9781.png" alt="img"></p><ul><li>编译器<ul><li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</li></ul></li><li>解释器<ul><li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</li></ul></li></ul><h3 id="V8怎么执行JS代码？"><a href="#V8怎么执行JS代码？" class="headerlink" title="V8怎么执行JS代码？"></a>V8怎么执行JS代码？</h3><p>预览图</p><p><img src="https://static001.geekbang.org/resource/image/1a/ae/1af282bdc4036096c03074da53eb84ae.png" alt="img"></p><p>V8 在执行过程中既有<em>解释器 Ignition</em>，又有<em>编译器 TurboFan</em></p><p>字节码与汇编属于同一级别</p><ul><li>生成抽象语法树AST和执行上下文<ul><li>先生成AST才生成执行上下文</li><li>高级语言开发者可以理解，但是让编译器和解释器理解就非常困难，编译和解释器可以理解的就是AST，</li></ul></li></ul><h4 id="AST生成阶段"><a href="#AST生成阶段" class="headerlink" title="AST生成阶段"></a>AST生成阶段</h4><ul><li>第一阶段是分词（tokenize），又称为词法分析</li><li>第二阶段是解析（parse），又称为语法分析，</li></ul><h4 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h4><blockquote><p>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</p></blockquote><p>之前是生成字节码 不生成机器码，后来因为内存占用问题，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。</p><h4 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h4><p><img src="https://static001.geekbang.org/resource/image/66/8a/662413313149f66fe0880113cb6ab98a.png" alt="img"></p><ul><li>热点代码<ul><li>在 Ignition 执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</li></ul></li><li>JIT 即时编译<ul><li>具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。</li></ul></li></ul><h3 id="JS性能优化"><a href="#JS性能优化" class="headerlink" title="JS性能优化"></a>JS性能优化</h3><ul><li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li><li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li><li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器工作原理与实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码整洁之道，程序员的职业素养读后感</title>
    <link href="/sevenflow.blog/2021/05/25/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB/"/>
    <url>/sevenflow.blog/2021/05/25/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="代码整洁之道，程序员的职业素养读后感"><a href="#代码整洁之道，程序员的职业素养读后感" class="headerlink" title="代码整洁之道，程序员的职业素养读后感"></a>代码整洁之道，程序员的职业素养读后感</h1><h2 id="章节总结"><a href="#章节总结" class="headerlink" title="章节总结"></a>章节总结</h2><h3 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h3><ul><li>勇于向不合理需求说不</li></ul><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><ul><li>论为什么要做一个有职业素养的人</li></ul><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul><li>作者对于职业素养理解的背景</li></ul><h3 id="专业主义"><a href="#专业主义" class="headerlink" title="专业主义"></a>专业主义</h3><ul><li>不要让测试人员给你兜底</li><li>不要破坏原有功能</li><li>对于自己写的代码，应该不怕重构，经常重构</li><li>了解你的领域</li><li>保持精进，保持学习，保持练习</li><li>学会向他人学习</li><li>学会把自己知道的知识进行传授</li><li>了解自己所做的业务，还要和团队保持一致</li><li>虚心使人进步骄傲使人落后</li></ul><h4 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h4><p>要做专业人员 道阻且长</p><h3 id="说不"><a href="#说不" class="headerlink" title="说不"></a>说不</h3><ul><li>对于完成不了的 应该直接说出来，说不应该有原因</li><li>勇于面对 对立关系，不要过于懒惰追求和谐，在告知底线的情况下 寻找解决方案。</li><li>风险应该暴露出来，越早暴露出来越好</li><li>说试试看的时候 应该心里有底</li></ul><h4 id="读后感-1"><a href="#读后感-1" class="headerlink" title="读后感"></a>读后感</h4><p>很难想象公司以这本书作为 新员工入职的 启蒙书，这个章节就是在和 现有大多数公司作对。</p><h4 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h4><blockquote><p>在经济全球化时代，企业唯利是图，为提升股价而采用裁员，员工过劳和外包等方法，我遇到的这种缩减开发成本的手段，已经消解了高质量程序的存在价值和事宜了，只要一个不小心，我们这些开发人员就可能会被要求，被指示或是被欺骗去花一半的时间写出两倍数量的代码</p></blockquote><h3 id="说是"><a href="#说是" class="headerlink" title="说是"></a>说是</h3><ul><li>对自己说的话 负责，说话时坚定一点 </li><li>明白说是代表着什么</li></ul><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ul><li>编码前做好准备，不要急于编码</li><li>不要让自己进入流态</li><li>减少焦虑</li><li>貌似编码时候不应该听歌</li><li>应该预防自己的思路被打断</li><li>当没有想法时，应该看一些创造性输入的资料</li><li>要反复调试你的程序，调试时间应该算在你的开发时间里</li><li>保持正常节奏，不要让自己疲劳编码</li><li>对自己的进度应该保持透明，不要对自己的交付和失误撒谎</li><li>诚心接受他人帮助，也诚心帮助他人</li></ul><h4 id="摘抄-1"><a href="#摘抄-1" class="headerlink" title="摘抄"></a>摘抄</h4><blockquote><p>编程很难，事实上仅凭一己之力无法写出优秀的代码，即使你的技能格外高超，也肯定能从另外一名程序员的思考和想法中收益。</p></blockquote><h3 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h3><ul><li>TDD 是开发必需品</li><li>测试代码先于产品代码之前，测试代码依赖产品代码，双方同时进行</li><li>TDD增加确定性</li><li>减少缺陷注入率</li><li>让重构更为简单</li><li>让文档书写更为简单</li><li>先写代码测试可以 让 你的代码设计更为完美</li><li>好吧幸好最后 作者说了 要根据场景来选择是否需要TDD，要不我都怀疑 我白做了这几年开发</li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li>坚持练习</li><li>为开源贡献代码</li></ul><h3 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h3><ul><li>客户对功能的设想是经不起真刀真枪的考研的</li><li>不要过度追求精确目标</li><li>不要过度预估焦虑，允许误差</li><li>随时保持沟通</li><li>自动化测试</li><li>开发人员应该随时协商并且改进测试</li><li>GUI界面应该按照功能流程测试 </li><li>持续集成很重要，只要有人提交代码就应该持续单元测试和验收测试（国内大部分都是验收测试）</li></ul><h4 id="摘抄-2"><a href="#摘抄-2" class="headerlink" title="摘抄"></a>摘抄</h4><blockquote><p>“输入糟糕，输出也会糟糕”</p></blockquote><blockquote><p>在工作中有一种叫观察者效应，或者不确定原则，每次你向业务方展示一项功能，他们就获得了比之前更多的信息，这新新信息会反过来影响他们对整个系统的看法</p></blockquote><blockquote><p>请记住，身为专业开发人员，你的职责是协助团队开发出最棒的软件。也就是说，每个人都需要关心错误和疏忽，并协力改正。</p></blockquote><h3 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h3><ul><li>不要把QA当作兜底行为</li><li>自动测试金字塔<ul><li>5% 人工探索式测试（国内最常见的测试）</li><li>10%系统测试</li><li>20% 集成测试</li><li>50% 组件测试</li><li>100% 单元测试</li></ul></li></ul><h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><ul><li>时间规划很重要，可以安排自己一天的事情。</li><li>会议成本很高，没有必要不要进行会议，学会拒绝以及即时离席。</li><li>会议要确定主题和议程</li><li>避免过度争论，用数据说话，站队会议尽量不要参加</li><li>注意力集中的时候应该干重要的事情</li><li>保持好的睡眠，及时恢复体力</li><li>善于利用番茄工作法</li><li>不要陷入泥潭和死胡同，及时发现纠正。</li><li>保持开明的态度！！！</li></ul><h4 id="摘抄-3"><a href="#摘抄-3" class="headerlink" title="摘抄"></a>摘抄</h4><blockquote><p>专业开发人员会评估每个任务的优先级，排除个人的喜好和需要，按照真实的紧急程度来执行任务</p></blockquote><h3 id="预估"><a href="#预估" class="headerlink" title="预估"></a>预估</h3><ul><li>弄清楚承诺与预估的区别，预估是猜测。</li><li>PERT计划评审技术<ul><li>分为乐观预估，标称预估，悲观预估</li></ul></li><li>德尔菲法预算</li><li>利用大数定律 对大任务进行拆解然后再预估，最后把时间合起来。</li><li>专业开发人员不确定的事情不会做出承诺。</li></ul><h4 id="摘抄-4"><a href="#摘抄-4" class="headerlink" title="摘抄"></a>摘抄</h4><blockquote><p>问题在于，不同的人对预估有不同的看法。业务方觉得预估就是承诺，开发方认为预估就是猜测，两者相差迥异。</p></blockquote><h3 id="压力"><a href="#压力" class="headerlink" title="压力"></a>压力</h3><ul><li>避免压力之前不要轻易做出承诺</li><li>让代码整洁起来 让自己编码舒服起来</li><li>当身处困境时 不要放弃自己之前的纪律性。</li><li>保持冷静</li></ul><h4 id="摘抄-5"><a href="#摘抄-5" class="headerlink" title="摘抄"></a>摘抄</h4><blockquote><p>及时有压力，专业开发人员也会冷静果断。尽管压力不断增大，他仍然1会坚守所受的训练和纪律，他知道这些是他赖以战胜由最后期限和承诺所带来的压力感的最好方法</p></blockquote><h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><ul><li>工作职责就是让公司长久的发展下去</li><li>必需理解业务</li><li>重视公司的需求，不要沉迷于自己世界</li><li>让别人接触你的代码</li><li>交流是程序员的必备技能之一</li></ul><h3 id="团队与项目"><a href="#团队与项目" class="headerlink" title="团队与项目"></a>团队与项目</h3><ul><li>不要让人员穿插项目</li><li>12人员的团队最有凝聚力</li><li>不要拆散有凝聚力的团队</li><li>好的团队比项目更难构建</li></ul><h3 id="辅导、学徒期与技艺"><a href="#辅导、学徒期与技艺" class="headerlink" title="辅导、学徒期与技艺"></a>辅导、学徒期与技艺</h3><ul><li>此书的作者12岁就开始接触编程，第一次编程则是按照手册进行编程</li><li>学会观察比自己厉害的人</li><li>辅导很重要，如果有辅导可以避免走很多弯路</li><li>程序员应该和医生一样有实习期和学徒期，而不是一开始就让他编程</li><li>十年左右才是大师，五年左右是熟练工，再往下就是实习生了</li></ul><h4 id="摘抄-6"><a href="#摘抄-6" class="headerlink" title="摘抄"></a>摘抄</h4><blockquote><p>技艺是工匠所持的精神状态。技艺的“模因”中包含着价值观、原则、技术、态度和正见</p></blockquote><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>源代码控制应该用开源的代码控制工具，建议工具就是git</li><li>IDE建议是用Intellij</li><li>持续继承用jenkins</li><li>原来Bob大叔 90年代就想过 MDA “模型驱动架构”</li></ul><h2 id="读后感-2"><a href="#读后感-2" class="headerlink" title="读后感"></a>读后感</h2><p>​        这本书减少了我盲目的焦虑感。</p><p>​        我总是觉得自己的基础很差，技术很烂，需要好好去看各种技术细节，熟知各种基础知识，而且一度认为业务是我代码道路上的绊脚石，如果我时间足够可以写出更牛逼的代码，但是看完之后我觉得好的程序员不止是”术“的造诣高深，还有各种”道“。</p><p>​        我工作已经快5年了，经常会去各种大牛博客看一些文章，想学习他们成为大牛的方法，或者说怎么成为一个好的程序员，而这本书至少在”道“上完全解答了我这个问题的困惑。</p><p>​        什么是好的程序员？程序员是一个工种，既然是工种那么必然和其他职业一样有他的原则和做事规范，这些统称为职业素养。当你拥有这些素养，就算技术不是很厉害，我觉得我至少也会让别人感觉是一个专业靠谱的程序员。</p><p>​        比如说不，说不其实是一种负责任的表现，让你对每次的需求慎重考虑而不是马马虎虎去对待，这就让工作协作少了很多不必要的麻烦。还有预估，我之前公司因为是敏捷开发的拥趸者又是一个外包业务性质的公司，让我对预估产生了很不好的感觉，觉得这就是上级与下级不信任的一种行为，因为担心下级不好好工作所以需要估时进行压缩时长从而节约成本，现在看来预估是工程化中非常重要的一环，只有认真对待预估，成本以及工作安排才可以有条不紊的进行下去这对一个公司来说十分重要，而且有利于公司的全部人力资源得到利用。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术书籍</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React+TS webpack配置步骤</title>
    <link href="/sevenflow.blog/2021/04/25/React+TS-webpack%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4/"/>
    <url>/sevenflow.blog/2021/04/25/React+TS-webpack%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="React-TS-webpack配置步骤"><a href="#React-TS-webpack配置步骤" class="headerlink" title="React+TS webpack配置步骤"></a>React+TS webpack配置步骤</h1><h2 id="工程化项目需求"><a href="#工程化项目需求" class="headerlink" title="工程化项目需求"></a>工程化项目需求</h2><ul><li>JS框架是react</li><li>ES6语法编译</li><li>支持热更新</li><li>支持环境变量</li><li>支持sass，less语法</li><li>支持图片资源加载</li><li>ESLINT&amp;CSSLINT</li><li>支持TS</li></ul><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><h3 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h3><p>在终端运行 <code>npm init</code> ,会让你输入以下的东西</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">package name: (react-ts-demo)<br><br></code></pre></td></tr></table></figure><h3 id="建立文件目录"><a href="#建立文件目录" class="headerlink" title="建立文件目录"></a>建立文件目录</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">+ public<br> index.html<br><br>+ src<br> *.js<br><br>- app.js<br><br>- webpack.config.js<br></code></pre></td></tr></table></figure><h3 id="安装必需依赖"><a href="#安装必需依赖" class="headerlink" title="安装必需依赖"></a>安装必需依赖</h3><h4 id="webpack相关"><a href="#webpack相关" class="headerlink" title="webpack相关"></a>webpack相关</h4><h4 id="bebal相关以及配置"><a href="#bebal相关以及配置" class="headerlink" title="bebal相关以及配置"></a>bebal相关以及配置</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;presets&quot;</span>: [<br>      [<span class="hljs-string">&quot;@babel/env&quot;</span>], <span class="hljs-comment">// es6 预处理</span><br>      [<span class="hljs-string">&quot;@babel/preset-react&quot;</span>] <span class="hljs-comment">// jsx语法处理</span><br>  ],<br>  <span class="hljs-attr">&quot;plugins&quot;</span>: [<span class="hljs-string">&quot;react-hot-loader/babel&quot;</span>] <span class="hljs-comment">// 热加载处理</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="webpack-config-js初始配置"><a href="#webpack-config-js初始配置" class="headerlink" title="webpack.config.js初始配置"></a>webpack.config.js初始配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建webpack配置文件</span><br><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-comment">// 导出配置</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    entry: <span class="hljs-string">&#x27;./app.js&#x27;</span>, <span class="hljs-comment">// 入口文件</span><br>    output: &#123;<br>      filename: <span class="hljs-string">&#x27;index.js&#x27;</span>, <span class="hljs-comment">// 打包名称</span><br>      path: path.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>), <span class="hljs-comment">// 打包路径</span><br>    &#125;,<br>    mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="React安装以及编写文件"><a href="#React安装以及编写文件" class="headerlink" title="React安装以及编写文件"></a>React安装以及编写文件</h3><h3 id="管理输出"><a href="#管理输出" class="headerlink" title="管理输出"></a>管理输出</h3><p>webapck文件如下</p><h3 id="开发服务处理"><a href="#开发服务处理" class="headerlink" title="开发服务处理"></a>开发服务处理</h3><h4 id="build的watch状态"><a href="#build的watch状态" class="headerlink" title="build的watch状态"></a>build的watch状态</h4><p>package.json文件如下</p><h4 id="devServer配置-热启动"><a href="#devServer配置-热启动" class="headerlink" title="devServer配置 热启动"></a>devServer配置 热启动</h4><p>webpack文件如下</p><h2 id="热加载"><a href="#热加载" class="headerlink" title="热加载"></a>热加载</h2><p>两者区别</p><p>Webpack HMR 和 React-Hot-Loader - 高山景行的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/30135527">https://zhuanlan.zhihu.com/p/30135527</a></p><h3 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h3><ul><li>webpack.config.js 配置</li><li>JS 写法</li></ul><h3 id="react-hot配置"><a href="#react-hot配置" class="headerlink" title="react-hot配置"></a>react-hot配置</h3><ul><li>安装依赖</li><li>写入bebal.config.json的配置</li><li>改写入口文件</li></ul><h2 id="环境变量处理"><a href="#环境变量处理" class="headerlink" title="环境变量处理"></a>环境变量处理</h2><h3 id="webpakc-config-js中获取"><a href="#webpakc-config-js中获取" class="headerlink" title="webpakc.config.js中获取"></a>webpakc.config.js中获取</h3><ul><li><p>用法</p><p>–env [NAME]=[变量]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;start:prd&quot;</span>: <span class="hljs-string">&quot;webpack serve --open --env NODEMODE=prd&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>获取</p><p>没使用插件情况下只能在webpack.config.js 获取，浏览器运行时无法获取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">env</span> =&gt;</span> &#123;<br> <span class="hljs-built_in">console</span>.log(env.NODEMODE) <span class="hljs-comment">// prd</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="运行时获取"><a href="#运行时获取" class="headerlink" title="运行时获取"></a>运行时获取</h3><p>使用webpack自带插件 DefinePlugin</p><ul><li><p>webpack.config.js 配置</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>); <span class="hljs-comment">// 默认全局变量</span><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">env</span> =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> &#123;<br>    ...,<br>    plugins: [ <span class="hljs-comment">// 插件管理</span><br>    <span class="hljs-comment">// 环境变量处理</span><br>      <span class="hljs-keyword">new</span> webpack.DefinePlugin(&#123;<br>        __DEV__: <span class="hljs-literal">false</span>,<br>      &#125;)<br>    ],<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>页面代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> List <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./list&#x27;</span><br><br><span class="hljs-keyword">const</span> show = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(__DEV__)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>  () =&gt; &#123;<br><br><span class="hljs-keyword">return</span> (&lt;div&gt;<br>        &lt;h1 onClick=&#123;show&#125;&gt;<span class="hljs-number">123</span>&lt;/h1&gt;<br>    &lt;/div&gt;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>处理为多个模式</p><p>  配置命令行</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&quot;start&quot;: &quot;webpack serve --open&quot;,<br>&quot;start:dev&quot;: &quot;webpack serve --open model=dev&quot;,<br>&quot;start:prd&quot;: &quot;webpack serve --open model=prd&quot;<br></code></pre></td></tr></table></figure><p>  后面的model 是不同类型，还需处理webpack.config.js 文件</p><ul><li><p>建立<code>env</code>文件夹，下面有文件夹 <code>index/prd/dev</code></p></li><li><p>利用·<code>model</code> 读取文件</p></li><li><p>然后在<code>DefinePlugin</code> 插件使用</p></li><li><p>需要注意的是 如果直接使用，会导致直接转为引用变量，所以需要用 <code>JSON.stringify(exportENV(env.model))</code>, <a href="https://zhuanlan.zhihu.com/p/133443240">参考阅读</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> exportENV = <span class="hljs-function">(<span class="hljs-params">env</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> currentENV = <span class="hljs-built_in">require</span>(path.resolve(__dirname, <span class="hljs-string">&#x27;env&#x27;</span>) + <span class="hljs-string">&#x27;/&#x27;</span> + (env ? env : <span class="hljs-string">&#x27;index&#x27;</span>) + <span class="hljs-string">&#x27;.js&#x27;</span>)<br>  <span class="hljs-keyword">return</span> currentENV;<br>&#125;<br><br><br><span class="hljs-comment">// 环境变量处理</span><br><span class="hljs-keyword">new</span> webpack.DefinePlugin(&#123;<br>  GLOBAL_ENV: <span class="hljs-built_in">JSON</span>.stringify(exportENV(env.model))<br>&#125;)<br><br><span class="hljs-comment">// 页面获取</span><br><span class="hljs-built_in">console</span>.log(GLOBAL_ENV)<br><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="css资源加载处理"><a href="#css资源加载处理" class="headerlink" title="css资源加载处理"></a>css资源加载处理</h2><blockquote><p>css资源加载包括，css-modules的命名处理方案解决 以及 预处理less 和 sass 的处理</p></blockquote><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>style-loader 是为了处理css样式到Dom结构 需要在 文件里单独引入 css文件所以就需要 <code>import &#39;./index.csss&#39;</code>，但是正常是不支持直接import css 文件的，所以需要 css-loader 来处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yarn add style-loader css-loader -D<br></code></pre></td></tr></table></figure><h3 id="webpack配置-1"><a href="#webpack配置-1" class="headerlink" title="webpack配置"></a>webpack配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>: &#123;<br>    rules: [ <span class="hljs-comment">// 配置加载器</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/i</span>,<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>],<br>      &#125;<br>    ]<br>  &#125;,<br></code></pre></td></tr></table></figure><h3 id="进一步解决问题"><a href="#进一步解决问题" class="headerlink" title="进一步解决问题"></a>进一步解决问题</h3><h4 id="怎么处理命名冲突问题？"><a href="#怎么处理命名冲突问题？" class="headerlink" title="怎么处理命名冲突问题？"></a>怎么处理命名冲突问题？</h4><blockquote><p>css-loader的module配置项</p></blockquote><ul><li><p>配置如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>: &#123;<br>    rules: [ <span class="hljs-comment">// 配置加载器</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/i</span>,<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, &#123;<br>            loader: <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>            options: &#123;<br>              modules: &#123;<br>                localIdentName: <span class="hljs-string">&quot;[path][name]__[local]--[hash:base64:5]&quot;</span>,<span class="hljs-comment">// 解决 css冲突问题</span><br>              &#125;,<br>            &#125;<br>          &#125;<br>          ],<br>      &#125;<br>    ]<br>  &#125;,<br></code></pre></td></tr></table></figure></li><li><p>需要注意的</p><p>之前页面上写class 直接引入即可，但是现在不行 , 原因是module处理了css的命名规则，直接写 导致命名不对，所以只能动态引入如下对比</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 之前</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span><br><br><span class="hljs-keyword">const</span> index = <span class="hljs-function">() =&gt;</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">// 启用modules之后</span><br><br><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index.css&#x27;</span><br><br><span class="hljs-keyword">const</span> index = <span class="hljs-function">() =&gt;</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;stles.app&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h4 id="使用预处理less"><a href="#使用预处理less" class="headerlink" title="使用预处理less"></a>使用预处理less</h4><ul><li><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yarn add less less-loader -D<br></code></pre></td></tr></table></figure></li><li><p>webpack 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>: &#123;<br>    rules: [ <span class="hljs-comment">// 配置加载器</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/i</span>,<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, &#123;<br>            loader: <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>            options: &#123;<br>              modules: &#123;<br>                localIdentName: <span class="hljs-string">&quot;[path][name]__[local]--[hash:base64:5]&quot;</span>,<span class="hljs-comment">// 解决 css冲突问题</span><br>              &#125;,<br>            &#125;<br>          &#125;<br>          ],<br>      &#125;,<br>      <span class="hljs-string">&#x27;less-loader&#x27;</span>, <span class="hljs-comment">// 预处理</span><br>    ]<br>  &#125;,<br></code></pre></td></tr></table></figure></li></ul><h4 id="打包后的style是由js加载到-没做到分离"><a href="#打包后的style是由js加载到-没做到分离" class="headerlink" title="打包后的style是由js加载到 没做到分离"></a>打包后的style是由js加载到 没做到分离</h4><ul><li><p>安装依赖</p><ul><li>mini-css-extract-plugin 抽离css</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yarn add mini-css-extract-plugin<br></code></pre></td></tr></table></figure><ul><li><p>webpack配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-comment">// 抽取css成单独文件</span><br><span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">env</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        ...,<br>        <span class="hljs-built_in">module</span>: &#123;<br>            rules: &#123;<br>   ...,<br>            &#123;<br>              test: <span class="hljs-regexp">/\.(c|le)ss$/i</span>,<br>              use: [<br>                <span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-comment">// 解决css插入dom问题</span><br>                MiniCssExtractPlugin.loader, <span class="hljs-comment">// 抽取css文件</span><br>                &#123;<br>                  loader: <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>                  options: &#123;<br>                    modules: &#123;<br>                      localIdentName: <span class="hljs-string">&quot;[path][name]__[local]--[hash:base64:5]&quot;</span>, <span class="hljs-comment">// 解决 css冲突问题, 比较齐全的配置看文档 https://webpack.docschina.org/loaders/css-loader/#modules</span><br>                    &#125;,<br>                  &#125;<br>                &#125;, <span class="hljs-comment">// 解决 import 引入css问题</span><br>                <span class="hljs-string">&#x27;less-loader&#x27;</span>, <span class="hljs-comment">// 预处理</span><br>              ],<br>            &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置完成后会发现，这个顺序是固定的，改变一个会导致报错，所以需要注意，然后还会发现 虽然css抽离出来了 但是 dom中并没有相关的class命名如下</p><p><img src="C:\Users\7\AppData\Roaming\Typora\typora-user-images\image-20210615225132799.png" alt="image-20210615225132799"></p></li></ul></li></ul><p><img src="C:\Users\7\AppData\Roaming\Typora\typora-user-images\image-20210615225154660.png" alt="image-20210615225154660"></p><p>​    但是资源中是有css文件的，接下来继续看文档找一下答案 ，答案地址 <a href="https://webpack.docschina.org/plugins/mini-css-extract-plugin/#modules">https://webpack.docschina.org/plugins/mini-css-extract-plugin/#modules</a></p><blockquote><p><em>i 不要同时使用</em> <code>style-loader</code> <em>与</em> <code>mini-css-extract-plugin</code><em>。</em></p></blockquote><p>​ 下面是解决方案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 命令行处理</span><br> <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --env css=dev&quot;</span>, <span class="hljs-comment">// 只给build加 因为开发模式用style-loader更快</span><br>     <br><span class="hljs-comment">// webpack  配置</span><br>     <br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">env, args</span>) =&gt;</span> &#123;<br><br><span class="hljs-comment">// dev 模式</span><br><span class="hljs-keyword">const</span> cssTypeDev = args.css === <span class="hljs-string">&#x27;dev&#x27;</span>;<br><br> <span class="hljs-keyword">return</span> &#123;<br> ...,<br>     <span class="hljs-built_in">module</span>: &#123;<br>      rules: &#123;<br>       ...,<br>            &#123;<br>              test: <span class="hljs-regexp">/\.(c|le)ss$/i</span>,<br>              use: [<br>                cssTypeDev ? <span class="hljs-string">&#x27;style-loader&#x27;</span> : &#123;<br>                  loader: MiniCssExtractPlugin.loader,<br>                &#125;, <span class="hljs-comment">// 抽取css文件 &#x27;style-loader&#x27;, // 解决css插入dom问题 这个判断是为了解决两个不能同时使用的问题</span><br>                &#123;<br>                  loader: <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>                  options: &#123;<br>                    modules: &#123;<br>                      localIdentName: <span class="hljs-string">&quot;[path][name]__[local]--[hash:base64:5]&quot;</span>, <span class="hljs-comment">// 解决 css冲突问题, 比较齐全的配置看文档 https://webpack.docschina.org/loaders/css-loader/#modules</span><br>                    &#125;,<br>                  &#125;<br>                &#125;, <span class="hljs-comment">// 解决 import 引入css问题</span><br>                <span class="hljs-string">&#x27;less-loader&#x27;</span>, <span class="hljs-comment">// 预处理</span><br>              ],<br>            &#125;<br>         &#125;<br>        plugins: [ <span class="hljs-comment">// 插件管理</span><br>          ...,<br>          <span class="hljs-comment">// 抽取css文件</span><br>          !cssTypeDev ? <span class="hljs-keyword">new</span> MiniCssExtractPlugin() : []<br>        ],<br>     &#125;<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h4><p>安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yarn add css-minimizer-webpack-plugin<br></code></pre></td></tr></table></figure><p>webpack配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">...<br><br><span class="hljs-comment">// 压缩css用的</span><br><span class="hljs-keyword">const</span> CssMinimizerPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;css-minimizer-webpack-plugin&#x27;</span>);<br>...<br><br><br><br><span class="hljs-comment">// 导出配置</span><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">env, args</span>) =&gt;</span> &#123;<br> <span class="hljs-keyword">return</span> &#123;<br>        ...,<br>        optimization: &#123;<br>          minimize: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 允许优化</span><br>          minimizer: [<br>            <span class="hljs-keyword">new</span> CssMinimizerPlugin(), <span class="hljs-comment">// 压缩css</span><br>          ]<br>        &#125;,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图片资源处理"><a href="#图片资源处理" class="headerlink" title="图片资源处理"></a>图片资源处理</h2><h3 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yarn add file-loader -D<br></code></pre></td></tr></table></figure><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导出配置</span><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">env, args</span>) =&gt;</span> &#123;<br> <span class="hljs-keyword">return</span> &#123;<br>        ...,<br>        <span class="hljs-built_in">module</span>: &#123;<br>          rules: [ <span class="hljs-comment">// 配置加载器</span><br>                &#123;<br>                  test: <span class="hljs-regexp">/\.(png|jpe?g|gif)$/i</span>,<br>                  use: [<br>                    &#123;<br>                      loader: <span class="hljs-string">&#x27;file-loader&#x27;</span><br>                    &#125;<br>                  ]<br>                &#125;, <span class="hljs-comment">// 文件处理</span><br>            &#125;,<br>          ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="集成ESLINT"><a href="#集成ESLINT" class="headerlink" title="集成ESLINT"></a>集成ESLINT</h2><blockquote><p>默认vscode已经安装eslint依赖，并且开启</p><p>// 每次保存的时候将代码按eslint格式进行修复*</p><p>“editor.codeActionsOnSave”: {</p><p>​    “source.fixAll”: true</p><p>}</p></blockquote><h3 id="安装依赖-2"><a href="#安装依赖-2" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yarn add eslint babel-eslint eslint-plugin-import eslint-config-ali  -D<br></code></pre></td></tr></table></figure><h3 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h3><ul><li><p>新建文件 <code>.eslintrc</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-attr">&quot;extends&quot;:</span> [<br>        <span class="hljs-string">&quot;eslint-config-ali&quot;</span>,<br>        <span class="hljs-string">&quot;eslint-config-ali/react&quot;</span><br>        <span class="hljs-string">//</span> <span class="hljs-string">&quot;eslint-config-ali/jsx-a11y&quot;</span> <span class="hljs-string">//</span> <span class="hljs-string">无障碍辅助功能</span><br>    ],<br>    <span class="hljs-attr">&quot;rules&quot;:</span> &#123;<br>        <span class="hljs-attr">&quot;semi&quot;:</span> [<span class="hljs-number">2</span>, <span class="hljs-string">&quot;never&quot;</span>],<br>        <span class="hljs-attr">&quot;no-console&quot;:</span> <span class="hljs-string">&quot;off&quot;</span>,<br>        <span class="hljs-attr">&quot;react/no-array-index-key&quot;:</span> <span class="hljs-string">&quot;off&quot;</span>,<br>        <span class="hljs-string">&quot;react/prop-types&quot;</span><span class="hljs-string">:&quot;off&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;globals&quot;:</span> &#123; <span class="hljs-string">//</span> <span class="hljs-string">防止全局变量报错</span><br>        <span class="hljs-attr">&quot;GLOBAL_ENV&quot;:</span> <span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;ignorePatterns&quot;:</span> [ <span class="hljs-string">//</span> <span class="hljs-string">忽略文件夹</span><br>        <span class="hljs-string">&quot;dist&quot;</span>,<br>        <span class="hljs-string">&quot;node_modules&quot;</span>,<br>        <span class="hljs-string">&quot;*.d.ts&quot;</span><br>    ]<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>现在只是jslint 风格ok，如果需要react需要 安装阿里的 其他lint包 如下</p><h3 id="安装依赖-3"><a href="#安装依赖-3" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yarn add eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-jsx-a11y -D<br></code></pre></td></tr></table></figure><h3 id="文件配置-1"><a href="#文件配置-1" class="headerlink" title="文件配置"></a>文件配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-attr">&quot;extends&quot;:</span> [<br>        <span class="hljs-string">&quot;eslint-config-ali&quot;</span>,<br>        <span class="hljs-string">&quot;eslint-config-ali/react&quot;</span>,<br>        <span class="hljs-string">&quot;eslint-config-ali/jsx-a11y&quot;</span><br>    ],<br>    <span class="hljs-attr">&quot;rules&quot;:</span> &#123;<br>        <span class="hljs-attr">&quot;semi&quot;:</span> [<span class="hljs-number">2</span>, <span class="hljs-string">&quot;never&quot;</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="集成TS"><a href="#集成TS" class="headerlink" title="集成TS"></a>集成TS</h2><h3 id="安装依赖-4"><a href="#安装依赖-4" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>@babel/preset-typescript 是babel转义ts</p><p>@types/react 是react依赖的类型库</p><p>不需要ts-loader因为 babel的转译更快</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yarn add typescript @babel/preset-typescript @types/react @types/react-dom @types/webpack-env -D <br></code></pre></td></tr></table></figure><h3 id="bebel-config-json修改"><a href="#bebel-config-json修改" class="headerlink" title="bebel.config.json修改"></a>bebel.config.json修改</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;presets&quot;</span>: [<span class="hljs-string">&quot;@babel/env&quot;</span>, <span class="hljs-string">&quot;@babel/preset-react&quot;</span>, [<span class="hljs-string">&quot;@babel/preset-typescript&quot;</span>]], <span class="hljs-comment">// 新增</span><br>  <span class="hljs-attr">&quot;plugins&quot;</span>: [<span class="hljs-string">&quot;react-hot-loader/babel&quot;</span>]<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="webpack修改"><a href="#webpack修改" class="headerlink" title="webpack修改"></a>webpack修改</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">env, args</span>) =&gt;</span> &#123;<br><span class="hljs-comment">// prd 模式</span><br>  <span class="hljs-keyword">const</span> cssTypePrd = args.env.css === <span class="hljs-string">&#x27;prd&#x27;</span><br><br>  <span class="hljs-keyword">return</span> &#123;<br>    entry: <span class="hljs-string">&#x27;./app.tsx&#x27;</span>, <span class="hljs-comment">// 入口文件</span><br>    <span class="hljs-built_in">module</span>: &#123;<br>        rules: [ <span class="hljs-comment">// 配置加载器</span><br>        &#123;<br>          test: <span class="hljs-regexp">/\.(jsx|tsx|js|ts)?$/</span>,<span class="hljs-comment">// 处理es6语法以及jsx语法</span><br>          loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>          include: [<br>            path.resolve(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>), <span class="hljs-comment">// 使用目录</span><br>            path.resolve(__dirname, <span class="hljs-string">&#x27;app.tsx&#x27;</span>), <span class="hljs-comment">// 使用文件</span><br>          ],<br>        &#125;,<br>        ]<br>    &#125;,<br>    resolve: &#123; <span class="hljs-comment">// 新增因为现在的文件变为了 tsx 和ts后缀名所以需要增加两个后缀名 tsx和ts</span><br>      extensions: [<span class="hljs-string">&#x27;.tsx&#x27;</span>, <span class="hljs-string">&#x27;.ts&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>, <span class="hljs-string">&#x27;.js&#x27;</span>], <span class="hljs-comment">// 尝试按顺序解析这些后缀名。如果有多个文件有相同的名字，但后缀名不同，webpack 会解析列在数组首位的后缀的文件 并跳过其余的后缀。</span><br>    &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>全部react文件更名为TSX 原因是tsx语义更强</p><h3 id="ts-config-json-文件"><a href="#ts-config-json-文件" class="headerlink" title="ts-config.json 文件"></a>ts-config.json 文件</h3><blockquote><p>虽然不需要ts-loader来进行转译，但是需要ts-config的配置和IDE协作</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123; <span class="hljs-comment">// 编译配置</span><br>        <span class="hljs-attr">&quot;jsx&quot;</span>: <span class="hljs-string">&quot;react&quot;</span>,<br>        <span class="hljs-attr">&quot;types&quot;</span>: [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;react&quot;</span>, <span class="hljs-string">&quot;react-dom&quot;</span>],<br>        <span class="hljs-attr">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">// 不生成文件，只做类型检查</span><br>        <span class="hljs-attr">&quot;noEmit&quot;</span>: <span class="hljs-literal">true</span>,        <br>    &#125;,<br>&#125;<br><span class="hljs-comment">// 参考链接 https://segmentfault.com/a/1190000021421461 </span><br><span class="hljs-comment">// https://juejin.cn/post/6844904052094926855#heading-17</span><br><span class="hljs-comment">// 这里没用ts-loader所亿tsconfig的作用只有给IDE提示</span><br></code></pre></td></tr></table></figure><h3 id="外部的文件类型声明"><a href="#外部的文件类型声明" class="headerlink" title="外部的文件类型声明"></a>外部的文件类型声明</h3><blockquote><p>在完成这些后会发现less 还有 img文件的import会标红，因为这些文件都需要类型声明 还有全局变量</p></blockquote><p>新建一个 externals.d.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-built_in">module</span> <span class="hljs-string">&#x27;*.less&#x27;</span> &#123; <span class="hljs-comment">// less报错</span><br><br>    <span class="hljs-keyword">const</span> classes: &#123; [className: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> &#125;;<br>  <br>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> classes;<br>  <br>   &#125;<br><br><span class="hljs-comment">// 文件报错声明</span><br><span class="hljs-keyword">declare</span> <span class="hljs-built_in">module</span> <span class="hljs-string">&#x27;*.svg&#x27;</span><br><br><span class="hljs-keyword">declare</span> <span class="hljs-built_in">module</span> <span class="hljs-string">&#x27;*.png&#x27;</span><br><br><span class="hljs-keyword">declare</span> <span class="hljs-built_in">module</span> <span class="hljs-string">&#x27;*.jpg&#x27;</span><br><br><span class="hljs-keyword">declare</span> <span class="hljs-built_in">module</span> <span class="hljs-string">&#x27;*.jpeg&#x27;</span><br><br><span class="hljs-keyword">declare</span> <span class="hljs-built_in">module</span> <span class="hljs-string">&#x27;*.gif&#x27;</span><br><br><span class="hljs-keyword">declare</span> <span class="hljs-built_in">module</span> <span class="hljs-string">&#x27;*.bmp&#x27;</span><br><br><span class="hljs-keyword">declare</span> <span class="hljs-built_in">module</span> <span class="hljs-string">&#x27;*.tiff&#x27;</span><br><br><span class="hljs-comment">// 全局变量</span><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> GLOBAL_ENV: <span class="hljs-built_in">string</span>;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span>: <span class="hljs-built_in">any</span>;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react webpack TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初学者购买服务器</title>
    <link href="/sevenflow.blog/2021/02/25/%E5%88%9D%E5%AD%A6%E8%80%85%E8%B4%AD%E4%B9%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/sevenflow.blog/2021/02/25/%E5%88%9D%E5%AD%A6%E8%80%85%E8%B4%AD%E4%B9%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="初学者购买服务器"><a href="#初学者购买服务器" class="headerlink" title="初学者购买服务器"></a>初学者购买服务器</h1><h2 id="选平台"><a href="#选平台" class="headerlink" title="选平台"></a>选平台</h2><ul><li>阿里<ul><li>选阿里，因为文档更齐全一点</li></ul></li><li>腾讯</li></ul><h2 id="选服务器类型"><a href="#选服务器类型" class="headerlink" title="选服务器类型"></a>选服务器类型</h2><ul><li>云服务器<ul><li>选云服务器 以后的升级更方便，而且迁移数据更方便。（后面都以阿里云的控制台为例），选的系统是Ubuntu的 18版本</li></ul></li><li>轻量服务器</li></ul><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>在购买后 如果你要远程连接你的服务器，刚开始你是没有设置 root 密码的 ，所以需要设置密码，设置密码后 才可 远程连接。</p><ul><li><p>修改过程</p><p>实例列表&gt;实例更多&gt;密码/密钥&gt;修改密码</p></li></ul><h2 id="服务器环境搭建"><a href="#服务器环境搭建" class="headerlink" title="服务器环境搭建"></a>服务器环境搭建</h2><p>Ubuntu 系统自带 apt 命令行工具</p><ul><li><p>node</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install node<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install git<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>nvm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/cnpm/nvm.git ~/.nvm<br>cd ~/.nvm<br>git checkout `git describe --abbrev=0 --tags`<br><span class="hljs-meta">#</span><span class="bash"> 激活nvm</span><br>echo &quot;. ~/.nvm/nvm.sh&quot; &gt;&gt; /etc/profile<br>source /etc/profile<br></code></pre></td></tr></table></figure></li><li><p>nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install nginx<br><span class="hljs-meta">#</span><span class="bash"> 安装完成后 nginx会自动启动 ，可以查看一下nginx的启动状态</span><br>sudo systemctl status nginx<br></code></pre></td></tr></table></figure><ul><li><p>配置防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ufw allow &#x27;Nginx Full&#x27;<br></code></pre></td></tr></table></figure></li><li></li></ul></li></ul><h2 id="测试搭建"><a href="#测试搭建" class="headerlink" title="测试搭建"></a>测试搭建</h2><p>有node环境 直接用node创建服务</p><ul><li><p>写一个简易的端口监听文件。 先进入远程控制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir www &amp;&amp; cd www<br>touch index.js &amp;&amp; sudo vim index.js<br></code></pre></td></tr></table></figure></li><li><p>编写代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> hostname = <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>;<br><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<br><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.statusCode = <span class="hljs-number">200</span>;<br>    res.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/plain&#x27;</span>);<br>    res.end(<span class="hljs-string">&#x27;Hello World\n&#x27;</span>);<br>&#125;);<br><br>server.listen(port, hostname, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Server running at http://<span class="hljs-subst">$&#123;hostname&#125;</span>:<span class="hljs-subst">$&#123;port&#125;</span>/`</span>);<br>&#125;);                         <br></code></pre></td></tr></table></figure></li><li><p>运行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">node index.js<br></code></pre></td></tr></table></figure></li><li><p>进入控制台，配置入口</p><ul><li>点击安全组</li><li>点击配置规则</li><li>在入方向手动添加规则</li><li>加入 监听 端口 以及 授权的对象也就是 hostname</li></ul></li><li><p>复制自己的公网ip</p></li><li><p>浏览器 访问 http:// ip:端口号 </p></li></ul>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js数据类型的延伸</title>
    <link href="/sevenflow.blog/2021/01/25/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BB%B6%E4%BC%B8/"/>
    <url>/sevenflow.blog/2021/01/25/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BB%B6%E4%BC%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="js数据类型的延伸"><a href="#js数据类型的延伸" class="headerlink" title="js数据类型的延伸"></a>js数据类型的延伸</h1><p>这两天在复习基础知识，把之前的 觉得还存在模糊不清的知识想弄的再清楚一点，就针对数据类型的相关知识总结了一下</p><h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><blockquote><p>js的数据类型分为 值类型 和 引用类型 ，区分的依据就是本身不可变，只能重新赋值</p></blockquote><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><ul><li>string</li><li>number</li><li>boolean</li><li>null</li><li>undefined</li><li>Symbol </li><li>BigInt</li></ul><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul><li>Object<ul><li>Array</li><li>Function</li><li>RegExp</li><li>Date</li><li>…</li></ul></li></ul><h2 id="类型的识别"><a href="#类型的识别" class="headerlink" title="类型的识别"></a>类型的识别</h2><blockquote><p>如果有类型，那么就必须提到类型的识别，识别方法主要有以下几种</p></blockquote><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ul><li><p>使用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> &lt;值&gt; <span class="hljs-comment">// 值类型除了null以外都可以正常检测</span><br></code></pre></td></tr></table></figure></li><li><p>缺点</p><p>这个方法是有缺点的，无法检测引用类型的值，比如array和object检测出来都是 object，包括原始值null也是object</p></li><li><p>问题</p><ul><li><p>为什么 typeof 检测null也是 object，引用类型也是object</p><p>js是32位BIT 来存储值的，而且使用值的第 1 位 - 3 位来识别类型，而 null 与 object 的低三位都是 0 ，所以导致检测出现问题。</p></li><li><p>为什么官方不改进？</p><p>害怕出现旧项目不兼容问题，所以迟迟没有改动</p></li></ul></li></ul><h3 id="instanceOf"><a href="#instanceOf" class="headerlink" title="instanceOf"></a>instanceOf</h3><ul><li><p>使用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = []<br>a <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// true </span><br></code></pre></td></tr></table></figure></li><li><p>缺点</p><ul><li>只可检测 引用类型，但是null不可用</li><li>检测 arr 类型时 直接 写Object 也是 true</li></ul></li><li><p>问题</p><ul><li><p>为什么无法检测null 而且 检测不精准</p><p>instanceof 运算符本身是用来检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，意思就是 必需是 new 出来的 实例，且值的自身有 构造函数才可以检测，但是值类型 是没有构造函数的 所以无法检测，而 array 的构造函数的原型 本身继承于 Object 所以导致检测不精准，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<br>a <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span>; <span class="hljs-comment">// false</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">1</span>);<br>b <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span>; <span class="hljs-comment">// true</span><br>b <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Number</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Array</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><ul><li><p>使用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">1</span>) <span class="hljs-comment">// [Object Number]</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(&lt;值&gt;) <span class="hljs-comment">// [Object 值类型]</span><br></code></pre></td></tr></table></figure></li><li><p>问题</p><ul><li><p>为什么 Object 的方法变指针后可以直接用来 检测类型？</p><p><code>toString()</code> 方法返回一个表示该对象的字符串。这句话的理解可以看下面代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// object</span><br><span class="hljs-built_in">Object</span>.prototype.toString() <span class="hljs-comment">// [object object]</span><br><span class="hljs-comment">// array</span><br><span class="hljs-built_in">Array</span>.prototype.toString() <span class="hljs-comment">// 预期 [object array] 实际 &#x27;&#x27;</span><br>[].toString() <span class="hljs-comment">// &#x27;&#x27;</span><br><br></code></pre></td></tr></table></figure></li></ul></li></ul><pre><code>array应该返回的是array 为什么直接是 字符串？因为不管是array 还是 function 原型上的 toString 方法都被重写了，删除之前重写的方法 会导致 tostring方法重新找到 Object上的内置方法，然后正常返回类型如下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 删除各对象改写的原型方法</span><br><span class="hljs-keyword">delete</span> <span class="hljs-built_in">Array</span>.prototype.toString<br><span class="hljs-keyword">delete</span> <span class="hljs-built_in">Function</span>.prototype.toString<br><br><span class="hljs-comment">// 然后进行使用</span><br><span class="hljs-built_in">Array</span>.prototype.toString() <span class="hljs-comment">// [object array] </span><br>[].toString() <span class="hljs-comment">// [object array] </span><br></code></pre></td></tr></table></figure>所以 想用 不被修改的 tostring方法直接 就得 Object.prototype.toString.call()MDN 示例代码如下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> toString = <span class="hljs-built_in">Object</span>.prototype.toString;<br><br>toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>); <span class="hljs-comment">// [object Date]</span><br>toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>); <span class="hljs-comment">// [object String]</span><br>toString.call(<span class="hljs-built_in">Math</span>); <span class="hljs-comment">// [object Math]</span><br><br><span class="hljs-comment">//Since JavaScript 1.8.5</span><br>toString.call(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// [object Undefined]</span><br>toString.call(<span class="hljs-literal">null</span>); <span class="hljs-comment">// [object Null]</span><br></code></pre></td></tr></table></figure>MDN 只是说了用法 却没有说原因 咱们还是不知道为什么这样可以识别类型，继续科学搜索。在掘金上有搜到 一篇文章 说了 tostring为什么 会返回类型。 - ES5  因为当一个 值 比如 A 在调用Object的tostring时 ，A值内部的 [[class]] 会被返回出来，这个class 就是js已经定义好的内部属性，值为一个类型字符串，可以用来判断值的类型。  详细解释  &gt; 本规范的每种内置对象都定义了 [[Class]] 内部属性的值。宿主对象的 [[Class]] 内部属性的值可以是除了 &quot;Arguments&quot;, &quot;Array&quot;, &quot;Boolean&quot;, &quot;Date&quot;, &quot;Error&quot;, &quot;Function&quot;, &quot;JSON&quot;, &quot;Math&quot;, &quot;Number&quot;, &quot;Object&quot;, &quot;RegExp&quot;, &quot;String&quot; 的任何字符串。[[Class]] 内部属性的值用于内部区分对象的种类。注，本规范中除了通过 Object.prototype.toString ( 见 15.2.4.2) 没有提供任何手段使程序访问此值。- ES6  &gt; 之前的 `[[Class]]` 不再使用，取而代之的是一系列的 `internal slot`，Internal slots 对应于与对象相关联并由各种ECMAScript规范算法使用的内部状态，它们没有对象属性，也不能被继承，根据具体的 Internal slot 规范，这种状态可以由任何ECMAScript语言类型或特定ECMAScript规范类型值的值组成文章链接 [谈谈 Object.prototype.toString](https://juejin.cn/post/6844903477940846600)</code></pre><h2 id="JS中值的存储"><a href="#JS中值的存储" class="headerlink" title="JS中值的存储"></a>JS中值的存储</h2><blockquote><p>在存储之前需要熟悉一些概念，比如 栈 比如 堆，以及内存。可以先简单看一下下面的参考文档了解</p></blockquote><h3 id="引用类型的存储"><a href="#引用类型的存储" class="headerlink" title="引用类型的存储"></a>引用类型的存储</h3><p>分为两部分存储，一个是地址，用栈的方式存储，一个是类型本身 在堆里存储，所以引用类型的赋值 会导致 浅拷贝问题，导致两个变量引用的是同一个值</p><h3 id="值类型的存储"><a href="#值类型的存储" class="headerlink" title="值类型的存储"></a>值类型的存储</h3><p>值类型 直接使用 栈存储的方式存储的，每次赋值都是创建一个新的内存对象，修改取值 赋值也更快</p><h3 id="不同值得存储所导致得问题"><a href="#不同值得存储所导致得问题" class="headerlink" title="不同值得存储所导致得问题"></a>不同值得存储所导致得问题</h3><h4 id="深浅拷贝问题"><a href="#深浅拷贝问题" class="headerlink" title="深浅拷贝问题"></a>深浅拷贝问题</h4><p>浅拷贝就是引用值所导致的</p><ul><li>缺点<ul><li>会导致值的污染</li></ul></li><li>解决方案<ul><li>JSON序列化<ul><li>缺点<ul><li>耗时长</li><li>会导致 import 引入的东西 和function 都变为字符串</li></ul></li></ul></li><li>递归解决</li></ul></li></ul><h2 id="关于BigInt"><a href="#关于BigInt" class="headerlink" title="关于BigInt"></a>关于BigInt</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString">Object.prototype.toString</a></p><p><a href="https://juejin.cn/post/6844903477940846600">谈谈 Object.prototype.toString</a></p><p><a href="https://juejin.cn/post/6844903873992196110">「前端进阶」JS中的栈内存堆内存</a></p><p><a href="https://juejin.cn/post/6844903869525262349">「前端进阶」JS中的内存管理</a></p><p><a href="https://juejin.cn/post/6844903869525262349">为什么用Object.prototype.toString.call(obj)检测对象类型?</a></p><p><a href="https://www.zhihu.com/question/319926787">栈究竟在哪里？</a></p><p><a href="https://www.ruanyifeng.com/blog/2013/11/stack.html">Stack的三种含义</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react的状态管理</title>
    <link href="/sevenflow.blog/2020/11/25/react%E7%9A%84redux/"/>
    <url>/sevenflow.blog/2020/11/25/react%E7%9A%84redux/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是状态管理"><a href="#什么是状态管理" class="headerlink" title="什么是状态管理"></a>什么是状态管理</h2><blockquote><p>对于跨组件状态进行统一管理，更加方便组件间的通信以及逻辑公用，状态就是对于组件来说可变的变量。</p></blockquote><h2 id="为什么需要状态管理"><a href="#为什么需要状态管理" class="headerlink" title="为什么需要状态管理"></a>为什么需要状态管理</h2><ul><li>随着应用的规模越来越大，功能越来越复杂，组件的抽象粒度会越来越细，在视图中组合起来后层级也会越来越深，能够方便的<strong>跨组件共享状态</strong>成为迫切的需求。</li><li>状态也需要按模块切分，状态的变更逻辑背后其实就是我们的业务逻辑，将其抽离出来能够彻底<strong>解耦ui和业务</strong>，有利于逻辑复用，以及持续的维护和迭代。</li><li>状态如果能够被集中的管理起来，并合理的派发有利于组件<strong>按需更新</strong>，缩小渲染范围，从而提高渲染性能</li></ul><h2 id="都有那些状态管理"><a href="#都有那些状态管理" class="headerlink" title="都有那些状态管理"></a>都有那些状态管理</h2><h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><ul><li>vuex</li></ul><h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><ul><li>redux</li></ul><p>其实主要是redux，剩下都是衍生出来的**<em>类redux**</em>的状态库，比如 <code>redux-sage,redux-thunk...</code></p><h2 id="redux的使用流程"><a href="#redux的使用流程" class="headerlink" title="redux的使用流程"></a>redux的使用流程</h2><h3 id="创建全局store属性"><a href="#创建全局store属性" class="headerlink" title="创建全局store属性"></a>创建全局store属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// store.js 文件</span><br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span><br><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span> <span class="hljs-comment">// 这个是修改store的文件</span><br><span class="hljs-keyword">const</span> store = createStore(reducer)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><h3 id="在reducers里写入store的值以及改变函数"><a href="#在reducers里写入store的值以及改变函数" class="headerlink" title="在reducers里写入store的值以及改变函数"></a>在reducers里写入store的值以及改变函数</h3><p>写入你要用的状态，以及改变状态的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// todos.js</span><br><span class="hljs-comment">// 类似与vuex里的mutions</span><br><span class="hljs-comment">// reducers必需是一个方法，方法内含有两个参数，一个初始值，一个action的提交对象，action的规则是必须是含有type的一个对象</span><br><span class="hljs-comment">// 而且必须是一个纯函数，什么是纯函数，就是不改变参数的函数就是纯函数</span><br><span class="hljs-keyword">const</span> todos = <span class="hljs-function">(<span class="hljs-params">state = [], action</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">switch</span>(action.type) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>:<br>            <span class="hljs-keyword">return</span> [<br>                ...state,<br>                &#123;<br>                    id: action.id,<br>                    text: action.text,<br>                    completed: <span class="hljs-literal">false</span><br>                &#125;<br>            ]<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;CHANGE_TODO&#x27;</span>:<br>            <span class="hljs-keyword">return</span> state.map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span>(res.id === action.id) &#123;<br>                    res.completed = !res.completed;<br>                &#125;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;)<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> state<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> todos<br></code></pre></td></tr></table></figure><p>和其他的状态管理合并然后导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> &#123; combineReducers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span><br><span class="hljs-keyword">import</span> todos <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./todos&#x27;</span> <span class="hljs-comment">// todo任务列表的状态</span><br><span class="hljs-keyword">import</span> visibilityFilter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./visibilityFilter&#x27;</span> <span class="hljs-comment">// 筛选的状态</span><br><span class="hljs-keyword">const</span> todoApp = combineReducers(&#123; <span class="hljs-comment">// 这里的 combineReducers 类似与vuex里的module，是为了更好的管理大型状态</span><br>    todos,<br>    visibilityFilter<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> todoApp<br><br></code></pre></td></tr></table></figure><h3 id="在组件上使用"><a href="#在组件上使用" class="headerlink" title="在组件上使用"></a>在组件上使用</h3><ul><li><p>获取定义好的状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../store&#x27;</span> <span class="hljs-comment">// 引入sore</span><br><br><span class="hljs-keyword">const</span> todos = store.getState().todos; <span class="hljs-comment">// 获取todos的状态</span><br></code></pre></td></tr></table></figure></li><li><p>修改状态</p><p>dispatch是唯一该正规改变state的方法，直接修改也可以但是并不规范，而且会导致调试工具无法处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../store&#x27;</span> <span class="hljs-comment">// 引入sore</span><br><br><span class="hljs-keyword">const</span> action = <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        type: <span class="hljs-string">&#x27;CHANGE_TODO&#x27;</span>,<br>        id<br>    &#125;;<br>&#125;;<span class="hljs-comment">// 定义cation</span><br><br>store.dispatch(action(<span class="hljs-number">1</span>));<span class="hljs-comment">// 使用dispatch执行reducer里的方法然后修改state</span><br><br></code></pre></td></tr></table></figure></li></ul><h3 id="store挂载到react的实例，然后state改变dom也可以响应"><a href="#store挂载到react的实例，然后state改变dom也可以响应" class="headerlink" title="store挂载到react的实例，然后state改变dom也可以响应"></a>store挂载到react的实例，然后state改变dom也可以响应</h3><p>​    所有前面的代码其实只是组件的行为对于state产生改变，或者用 state，但是并无法完成响应渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; render &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./containers/App&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><br><span class="hljs-comment">// 初次渲染</span><br>render(<br>    &lt;App /&gt;,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br><span class="hljs-comment">// 监听变化然后重新渲染, subscribe 监听属性</span><br>store.subscribe(<span class="hljs-function">()=&gt;</span> &#123;<br>    render(<br>        &lt;App /&gt;,<br>      <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>    )<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h3><ul><li>全局应该只有一个store作为状态管理</li><li>reducers应该是一个纯函数，不能修改参数，只能返回新的值</li><li><strong><em>type 没有校验重复名称，意思就是可以有相同的type会导致出现问题</em></strong></li></ul><h2 id="redux的基础api"><a href="#redux的基础api" class="headerlink" title="redux的基础api"></a>redux的基础api</h2><h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><ul><li>参数<ol><li><code>reducer</code> <em>(Function)</em>: 接收两个参数，分别是当前的 state 树和要处理的action，返回新的 state 树。</li><li>[<code>preloadedState</code>] <em>(any)</em>: 初始时的 state。也就是说只能初始化的时候传值，如果需要后端数据那么请求后再初始化</li><li><code>enhancer</code> <em>(Function)</em>: Store enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。说白了就是可以在这个里面对action的过程做一个拦截，做一些动作，比如记载action的提交记录之类的。</li></ol></li></ul><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><ul><li>getState()</li><li>dispatch(action)</li><li>subcribe(listener)</li><li>replaceReducer(nextReducer)</li></ul><p>着重说一下 <code>replaceReducer</code>,这个用法是可以替换当前的reducer，意思就是可以实现动态的reducer，比如可以给之前reducer增加新的reducer</p><h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h3><p>这个就是一个vuex里的module作用，可以组合多个reducer，传参也是reducer，示例如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">rootReducer = combineReducers(&#123;<span class="hljs-attr">potato</span>: potatoReducer, <span class="hljs-attr">tomato</span>: tomatoReducer&#125;)<br><span class="hljs-comment">// rootReducer 将返回如下的 state 对象</span><br>&#123;<br>  potato: &#123;<br>    <span class="hljs-comment">// ... potatoes, 和一些其他由 potatoReducer 管理的 state 对象 ... </span><br>  &#125;,<br>  tomato: &#123;<br>    <span class="hljs-comment">// ... tomatoes, 和一些其他由 tomatoReducer 管理的 state 对象，比如说 sauce 属性 ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><ul><li>&lt; Provider store&gt;</li></ul><ul><li>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</li></ul><h2 id="redux的调试工具"><a href="#redux的调试工具" class="headerlink" title="redux的调试工具"></a>redux的调试工具</h2><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><ul><li>有VPN的安装地址，<a href="https://chrome.google.com/webstore/search/redux?hl=zh-CN">redux DevTools</a></li><li>国内安装地址，<a href="https://chrome.zzzmh.cn/">极简插件</a></li></ul><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul><li><p>在入口文件写入 调用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; render &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span><br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span><br><span class="hljs-keyword">import</span> &#123; Provider &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/App&#x27;</span><br><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span><br><br><span class="hljs-comment">// 判断是否有redux的开发者工具</span><br><br><span class="hljs-keyword">const</span> reduxDevtools = <span class="hljs-built_in">window</span>.devToolsExtension ? <span class="hljs-built_in">window</span>.devToolsExtension() : <span class="hljs-function">()=&gt;</span>&#123;&#125;<br><br><span class="hljs-comment">// 使用即可</span><br><span class="hljs-keyword">const</span> store = createStore(reducer, reduxDevtools)<br><br>render(<br>  &lt;Provider store=&#123;store&#125;&gt;<br>    &lt;App /&gt;<br>  &lt;/Provider&gt;,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure></li><li><p>查看浏览器控制台redux的选项里面有了一些内容</p><p><img src="C:\Users\7\AppData\Roaming\Typora\typora-user-images\image-20200815131109731.png" alt="image-20200815131109731"></p></li></ul><h2 id="saga的出现"><a href="#saga的出现" class="headerlink" title="saga的出现"></a>saga的出现</h2><p>… </p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://cn.redux.js.org/docs/react-redux/">React-dedux</a></li><li><a href="https://segmentfault.com/a/1190000012142449">4 张动图解释为什么（什么时候）使用 Redux</a></li><li><a href="https://www.jianshu.com/p/c876eff736e7">redux调试工具</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于网页适配的总结</title>
    <link href="/sevenflow.blog/2020/11/25/%E5%85%B3%E4%BA%8E%E7%BD%91%E9%A1%B5%E9%80%82%E9%85%8D%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <url>/sevenflow.blog/2020/11/25/%E5%85%B3%E4%BA%8E%E7%BD%91%E9%A1%B5%E9%80%82%E9%85%8D%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p><a href="#intellectual">基础知识</a></p></li><li><p>   <a href="#pc">pc适配</a></p></li><li><p>   <a href="#bigScreen">大屏适配</a></p></li><li><p>   <a href="#modile">移动端适配</a></p></li><li><p>   <a href="#document">参考文档</a></p></li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a><span id='intellectual'>基础知识</span></h2><h4 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h4><p>像素是屏幕的最小单位，所以平常说的像素不是px，而是指设备屏幕的最小单位</p><h4 id="设备像素"><a href="#设备像素" class="headerlink" title="设备像素"></a><strong>设备像素</strong></h4><p>设备像素又称物理像素（physical pixel），设备能控制显示的最小单位（每个单位下有三个子像素（红黄蓝）这就是rgb色域），我们可以把这些像素看作成显示器上一个个的点，一般指的是分辨率。</p><blockquote><p>​    之前没出现 Retina（视网膜） 技术之前（苹果公司提出），1px对应的就是一个物理像素，随之出现2倍屏，3倍屏指的是之前对应的1物理像素对应相应2倍甚至3倍，苹果公司已经解决了相应的1px渲染到 retina 设备的适配问题，开发人员需要解决的是图片适配的问题，200*200图片在正常屏幕下正常显示，但是在2倍或者3倍的屏幕下会被放大2，3倍，所以图片一般要做2到3倍的适配。</p></blockquote><h4 id="逻辑像素"><a href="#逻辑像素" class="headerlink" title="逻辑像素"></a>逻辑像素</h4><p>独立于设备的用于逻辑上衡量像素的单位。CSS 像素就是逻辑像素，CSS 像素是 Web 编程的概念。一般指px，<strong>它是图像显示的基本单元，既不是一个确定的物理量，也不是一个点或者小方块，而是一个抽象概念</strong>。所以在谈论像素时一定<strong>要清楚它的上下文</strong>！对于web的设备逻辑像素可用<code>screen.width</code>和<code>screen.height</code>去取。</p><h4 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h4><p>设备分辨率 / 逻辑像素 = DPR（设备像素比）一般就是指的几倍屏，也可<code>window.devicePixelRatio</code>直接获取，是几倍屏就需要几倍的图片。</p><h4 id="vw-vh（css3新增）-兼容性"><a href="#vw-vh（css3新增）-兼容性" class="headerlink" title="vw / vh（css3新增）(兼容性)"></a>vw / vh（css3新增）(兼容性)</h4><ul><li>vw (设备的100%宽度)<ul><li>1vw = 浏览器可视宽度 /100</li></ul></li><li>vh(设备的100%高度)<ul><li>1vh =浏览器可视高度 /100</li></ul></li></ul><h4 id="vmin-vmax（css3新增）-兼容性"><a href="#vmin-vmax（css3新增）-兼容性" class="headerlink" title="vmin/vmax（css3新增）(兼容性)"></a>vmin/vmax（css3新增）(兼容性)</h4><ul><li>设备的高宽中哪一个小，哪个就是vmin，比如1920*1080，vmin代表的就是1080，所以1vmin就是 1080/100</li><li>vmax与之相反</li></ul><h4 id="rem-em"><a href="#rem-em" class="headerlink" title="rem/em"></a>rem/em</h4><ul><li>rem （css3新增）(兼容性)<ul><li><strong>相对于HTML 根元素的 font-size的大小定义</strong></li><li><strong>全局的rem大小是固定的</strong></li><li>不设置的情况下 因为浏览器默认HTML的font-size是16px，所以1rem=16px</li></ul></li><li>em<ul><li> em的值并不是固定的</li><li>em会继承父级元素的字体大小 </li><li>如果父级元素未定义，那么1em=16px</li></ul></li></ul><h4 id="媒体查询（css3新增）-兼容性"><a href="#媒体查询（css3新增）-兼容性" class="headerlink" title="媒体查询（css3新增）(兼容性)"></a>媒体查询（css3新增）(兼容性)</h4><ul><li>可以通过查询规则不同写入不同的css样式从而渲染</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries">逻辑操作符</a></li></ul><h4 id="meta信息"><a href="#meta信息" class="headerlink" title="meta信息"></a>meta信息</h4><ul><li><p>元信息 用来告知浏览器的网页设置</p></li><li><p>viewport 的 meta</p><ul><li>  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1,minimum-scale=1, user-scalable=no">  </li><li><pre><code class="tex">width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。height：和 width 相对应，指定高度。initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。maximum-scale：允许用户缩放到的最大比例。minimum-scale：允许用户缩放到的最小比例。user-scalable：用户是否可以手动缩放<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs"><br>    <br><br>## &lt;span id=&quot;pc&quot; &gt; PC适配 &lt;/span&gt;<br><br>#### [主流适配]( https://www.1688.com/ )<br><br>* 1200px的主体宽度居中展示<br>* 两侧用百分比展示<br><br>#### [流式适配]( [https://xgfe.github.io/2018/01/26/zhoushiqi/Web%E7%AB%AF%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/](https://xgfe.github.io/2018/01/26/zhoushiqi/Web端屏幕适配方案/) )<br><br>&gt; 栅格栏布局<br><br>- 设计师需要做栅格栏设计，页面均等为12份，然后所有的布局按照栅格栏的对齐线进行对齐<br>- 当需要缩放时进行百分比缩放即可<br>- 适合大量留白的页面，布局样式单一的页面 <br><br>#### [响应式适配]( https://www.bootcss.com/ )<br><br>&gt; 媒体查询<br><br>- 示例 <br><br>  - ```html<br>    &lt;!-- link元素中的CSS媒体查询 --&gt;<br>    &lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt;<br>    <br>    &lt;!-- 样式表中的CSS媒体查询 --&gt;<br>    &lt;style&gt;<br>    @media (max-width: 600px) &#123;<br>      .facet_sidebar &#123;<br>        display: none;<br>      &#125;<br>    &#125;<br>    &lt;/style&gt;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>提前写好相关的查询规则</p><ul><li>一般规则都是市面上的主流分辨率的宽度，</li></ul></li></ul><h2 id="大屏适配"><a href="#大屏适配" class="headerlink" title=" 大屏适配 "></a><span id="bigScreen" > 大屏适配 </span></h2><ul><li>对接<ul><li>大屏物理信息（大屏一般是led屏幕 ，有p系列的规则）<ul><li>得知大屏的物理信息自己可计算出实际可达最高分辨率，比如 12m*4m 大小的p50 led屏 ，p50的是1平方米 400 * 400 个点，可算出实际分辨率为 12*400 / 4 *400 = 4800/1600</li></ul></li><li><strong>大屏的分辨率（一定是甲方已知道的）</strong><ul><li>需要告知设计，设计需要按照该分辨率作图</li></ul></li><li>大屏的终端<ul><li>只有终端支持最高的分辨率，大屏才可显示最高分辨率</li></ul></li></ul></li><li>选用方案<ul><li>固定写法<ul><li>直接把大小全部写死</li></ul></li></ul></li></ul><h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title=" 移动端适配 "></a><span id="modile" > 移动端适配 </span></h2><h4 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h4><ul><li>现在各大厂的小程序采用的都是 rpx代替px来进行布局，其实他就是rem ，所以咱们不需要操心适配的事情</li></ul><h4 id="H5移动端"><a href="#H5移动端" class="headerlink" title="H5移动端"></a>H5移动端</h4><ul><li><p>流式布局</p><ul><li>简书，掘金（响应以及流式）</li></ul></li><li><p><strong>rem 布局</strong></p><ul><li><p><a href="https://github.com/amfe/lib-flexible">淘宝的 flexible </a></p><ul><li>利用不同分辨率下的 HTML 的font-size来控制 rem的大小，将屏幕分为10等份</li></ul></li><li><p>网上所流传的 rem 计算公式</p><ul><li><p>不同分辨率，不同比例</p></li><li><pre><code class="js">resize(originSize) &#123;      let widths = document.documentElement.clientWidth        var scale = (widths / originSize) * 200 //在X轴下求出比例并放大100倍。      document.getElementsByTagName(&#39;html&#39;)[0].style.fontSize = scale + &#39;px&#39;    &#125;</code></pre></li><li></li></ul></li></ul></li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title=" 参考文档 "></a><span id="document" > 参考文档 </span></h2><p><a href="%5Bhttps://xgfe.github.io/2018/01/26/zhoushiqi/Web%E7%AB%AF%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/%5D(https://xgfe.github.io/2018/01/26/zhoushiqi/Web%E7%AB%AF%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/)">Web 端屏幕适配方案</a></p><p><a href="https://juejin.im/post/5cd0f87d6fb9a0325031c7ae#heading-3">掌握web开发基础系列–物理像素、逻辑像素、css像素</a></p><p><a href="https://www.cnblogs.com/libin-1/p/7148377.html">什么是物理像素、虚拟像素、逻辑像素、设备像素，什么又是 PPI, DPI, DPR 和 DIP</a></p><p><a href="https://juejin.im/post/5d21a9bd5188255360190e7e#heading-1">浅谈-web屏幕适配的解决方案</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wsl 系统修改 bash 显示 git 分支名称</title>
    <link href="/sevenflow.blog/2020/11/25/wsl%E7%B3%BB%E7%BB%9F%E4%BF%AE%E6%94%B9bash%E6%98%BE%E7%A4%BAgit%E5%88%86%E6%94%AF%E5%90%8D%E7%A7%B0/"/>
    <url>/sevenflow.blog/2020/11/25/wsl%E7%B3%BB%E7%BB%9F%E4%BF%AE%E6%94%B9bash%E6%98%BE%E7%A4%BAgit%E5%88%86%E6%94%AF%E5%90%8D%E7%A7%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li>需要再 wsl 的命令行展示 git 分支名称</li></ul><h2 id="修改步骤"><a href="#修改步骤" class="headerlink" title="修改步骤"></a>修改步骤</h2><ul><li><p><code>cd ~</code></p></li><li><p><code>vim .bashrc</code></p></li><li><p>替换以下内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$color_prompt</span>&quot;</span> = yes ]; <span class="hljs-keyword">then</span><br>    PS1=<span class="hljs-string">&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#x27;</span><br><span class="hljs-keyword">else</span><br>    PS1=<span class="hljs-string">&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ &#x27;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>替换为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># Add git branch if its present to PS1</span><br><br><span class="hljs-function"><span class="hljs-title">parse_git_branch</span></span>() &#123;<br>git branch 2&gt; /dev/null | sed -e <span class="hljs-string">&#x27;/^[^*]/d&#x27;</span> -e <span class="hljs-string">&#x27;s/* \(.*\)/(\1)/&#x27;</span><br>&#125;<br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$color_prompt</span>&quot;</span> = yes ]; <span class="hljs-keyword">then</span><br>PS1=<span class="hljs-string">&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[01;31m\]$(parse_git_branch)\[\033[00m\]\$ &#x27;</span><br><span class="hljs-keyword">else</span><br>PS1=<span class="hljs-string">&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w$(parse_git_branch)\$ &#x27;</span><br><span class="hljs-keyword">fi</span><br><br></code></pre></td></tr></table></figure><p>结束于</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">unset</span> color_prompt force_color_prompt<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Modules学习笔记</title>
    <link href="/sevenflow.blog/2020/11/25/CSS-Modules%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/sevenflow.blog/2020/11/25/CSS-Modules%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h2><blockquote><p>CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。</p></blockquote><ul><li>产生局部作用域的唯一方法，就是使用一个独一无二的<code>class</code>的名字，不会与其他选择器重名。这就是 CSS Modules 的做法。<ul><li>构建工具会把标签上的class以及样式表里的都进行哈希编译，这样就只对组件有效了</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">/* 示例写法 */</span><br><span class="hljs-comment">/* 样式表正常写，组件需要按照变量的方式写class如下 */</span><br><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.css&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;h1 className=&#123;styles.title&#125;&gt;<br>      Hello World<br>    &lt;/h1&gt;<br>  );<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><blockquote><p>CSS Modules 允许使用<code>:global(.className)</code>的语法，声明一个全局规则。凡是这样声明的<code>class</code>，都不会被编译成哈希字符串。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css示例 */</span><br><span class="hljs-selector-pseudo">:global(.title)</span> &#123;<br>  <span class="hljs-attribute">color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">/* 示例写法 */</span><br><span class="hljs-comment">/* 组件正常写 */</span><br><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.css&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;h1 className=<span class="hljs-string">&quot;title&quot;</span>&gt;<br>      Hello World<br>    &lt;/h1&gt;<br>  );<br>&#125;;<br><br></code></pre></td></tr></table></figure><blockquote><p>CSS Modules 还提供一种显式的局部作用域语法<code>:local(.className)</code>，等同于<code>.className</code>，所以上面的<code>App.css</code>也可以写成下面这样</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 和正常写并没什么不同 */</span><br><span class="hljs-selector-pseudo">:local(.title)</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-selector-pseudo">:global(.title)</span> &#123;<br>  <span class="hljs-attribute">color</span>: green;<br>&#125;<br><span class="hljs-comment">/* 定义多个全局 */</span><br><span class="hljs-selector-pseudo">:global</span> &#123;<br>  .link &#123;<br>    <span class="hljs-selector-tag">color</span>: <span class="hljs-selector-tag">green</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">color</span>: yellow;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定制哈希类名"><a href="#定制哈希类名" class="headerlink" title="定制哈希类名"></a>定制哈希类名</h2><blockquote><p><code>css-loader</code>默认的哈希算法是<code>[hash:base64]</code>，这会将<code>.title</code>编译成<code>._3zyde4l1yATCOkgn-DBWEL</code>这样的字符串。webpack.config.js可以定制哈希字符串格式</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>: &#123;<br>  loaders: [<br>    <span class="hljs-comment">// ...</span><br>    &#123;<br>      test: <span class="hljs-regexp">/\.css$/</span>,<br>      loader: <span class="hljs-string">&quot;style-loader!css-loader?modules&amp;localIdentName=[path][name]---[local]---[hash:base64:5]&quot;</span> <span class="hljs-comment">// 表示取路径以及文件名称以及本来class的名称以及哈希的前五位，中间连接符可以随便起</span><br>    &#125;,<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="class的组合"><a href="#class的组合" class="headerlink" title="class的组合"></a>class的组合</h2><blockquote><p>在 CSS Modules 中，一个选择器可以继承另一个选择器的规则，这称为”组合”（<a href="https://github.com/css-modules/css-modules#composition">“composition”</a>）。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 示例 */</span><br><span class="hljs-selector-class">.className</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.title</span> &#123;<br>  <span class="hljs-attribute">composes</span>: className;<br>  <span class="hljs-attribute">composes</span>: className;<span class="hljs-comment">/* 可以写多个组合 */</span><br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果class与继承的class样式有重复的 会直接选用继承class的样式，因为组件编译下来直接是两个class 所以选后一个class的样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">data-reactroot</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;_2DHwuiHWMnKTOYG45T0x34 _10B-buq6_BEOTOl9urIjf8&quot;</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>类名分别是 &quot;_2DHwuiHWMnKTOYG45T0x34&quot; &quot;_10B-buq6_BEOTOl9urIjf8&quot;<br></code></pre></td></tr></table></figure><h2 id="输入其他模块"><a href="#输入其他模块" class="headerlink" title="输入其他模块"></a>输入其他模块</h2><blockquote><p>选择器也可以继承其他css文件里的规则</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* a.css */</span><br><span class="hljs-selector-class">.className</span> &#123;<br>    <span class="hljs-attribute">font-size</span>:<span class="hljs-number">12px</span>;<br>&#125;<br><span class="hljs-comment">/* b.css */</span><br><span class="hljs-selector-class">.title</span> &#123;<br>    <span class="hljs-attribute">composes</span>: className from <span class="hljs-string">&#x27;./a.css&#x27;</span>,<br>    color:red;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="输入变量"><a href="#输入变量" class="headerlink" title="输入变量"></a>输入变量</h2><blockquote><p>CSS Modules 支持使用变量，不过需要安装 PostCSS 和 <a href="https://github.com/css-modules/postcss-modules-values">postcss-modules-values</a>。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install --save postcss-loader postcss-modules-values<br></code></pre></td></tr></table></figure><p>把<code>postcss-loader</code>加入<a href="https://github.com/ruanyf/css-modules-demos/blob/master/demo06/webpack.config.js"><code>webpack.config.js</code></a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>test: <span class="hljs-regexp">/\.css$/</span>,<br>loader: <span class="hljs-string">&quot;style-loader!css-loader?modules!postcss-loader&quot;</span><br>&#125;,<br></code></pre></td></tr></table></figure><h2 id="react-creact-app使用css-module的方法"><a href="#react-creact-app使用css-module的方法" class="headerlink" title="react-creact-app使用css-module的方法"></a>react-creact-app使用css-module的方法</h2><ul><li><p>第一种</p><ul><li><p>新建css文件使加入 [name].module.css的命名规则，引入方式也有区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Button.module.css&#x27;</span>; <span class="hljs-comment">// 使用 CSS Modules 的方式引入</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./another-stylesheet.css&#x27;</span>; <span class="hljs-comment">// 普通引入</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>第二种</p><ul><li><p>打开react-creact-app的隐藏配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yarn eject<br></code></pre></td></tr></table></figure></li><li><p>在use属性执行的方法中添加 <code>modules:true</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>      test: cssRegex,<br>      exclude: cssModuleRegex,<br>      use: getStyleLoaders(&#123;<br>        importLoaders: <span class="hljs-number">1</span>,<br>        <span class="hljs-built_in">module</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// css-module模式开启</span><br>        sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,<br>      &#125;),<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后文件名称后面就不用加module了 直接 就可以按照cssmodule的方式使用就好</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
